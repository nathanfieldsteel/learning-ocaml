#+STARTUP: content

* Learning OCaml - notes

This is the notes file accompanying my attempt to learn ocaml.

** Goals
+ Learning OCaml.
+ Literate programming in org-mode.
** Notes on OCaml in org-mode

These variables control something about the way code gets
passed to and retrieved from the ocaml toplevel that emacs runs in the
background. The toplevel can look a little cluttered with this
expression repeated all over the place, but it's probably not worth changing.

#+begin_example emacs-lisp
  ;; (setq org-babel-ocaml-eoe-output "org-babel-ocaml-eoe")
  ;; (setq org-babel-ocaml-eoe-indicator "\"org-babel-ocaml-eoe\";;")

  (setq org-babel-ocaml-eoe-output "org-babel-ocaml-eoe")
  (setq org-babel-ocaml-eoe-indicator "\"org-babel-ocaml-eoe\";;")
#+end_example

The default behavior of source blocks may not be adequate for printing
results. For example the following source block shows its result, but
does not show the type of the result:

#+begin_src ocaml
    let x = 42;;
    x
#+end_src

#+RESULTS:
: 42

But with the verbatim tag, the type is displayed as well.

#+begin_src ocaml :results verbatim
    let x = 42;;
    x
#+end_src

#+RESULTS:
: - : int = 42

And in this source block, when a string printing function is called,
the printed string doesn't manage to make it to the results
line. Again, the verbatim tag seems fixes this

#+begin_src ocaml :results verbatim
print_string "hello\n"
#+end_src

#+RESULTS:
: hello
: - : unit = ()

There is also the ~:results output~ tag. This is similar to ~:results
verbatim~ but it deosn't seem to handle multi-line input:

#+begin_src ocaml :results output
print_string "hello\n"
#+end_src

#+RESULTS:
: hello

In the event that source blocks aren't sufficient, you can open the
actual running toplevel with ~M-x tuareg-run-ocaml~ and interact with
it directly.

** CS3110 - notes and exercises

#+begin_src ocaml
  let x = 42;;
#+end_src

#+RESULTS:
val x : int = 42

#+begin_src ocaml
  (fun x -> x + 3) 4;;
#+end_src

#+RESULTS:
: 7

*** DONE 2.9 Basics - Exercises:
**** DONE Values [★]
What is the type and value of each of the following OCaml expressions:

+ ~7 * (1 + 2 + 3)~
+ ~"CS " ^ string_of_int 3110~

The first is ~42 : int~, the second is ~CS 3110 : string~

#+begin_src ocaml results: output
7 * (1 + 2 + 3)
#+end_src

#+RESULTS:
: 42

#+begin_src ocaml
  "CS " ^ string_of_int 3110
#+end_src

#+RESULTS:
: CS 311
**** DONE Operators [★★]

+ Write an expression that multiplies 42 by 10
+ Write an expression that divides 3.14 by 2.0
+ Write an expression that computes 4.2 raised to the 7th power

  #+begin_src ocaml
    42 * 10
  #+end_src

  #+RESULTS:
  : 420

  #+begin_src ocaml
    3.14 /. 2.0
  #+end_src

  #+RESULTS:
  : 1.57

  #+begin_src ocaml
    let rec pow a b = match b with
      | 0 -> 1.0
      | b -> a *. pow a (b-1) in
        pow 4.2 7
  #+end_src

  #+RESULTS:
  : 23053.93332480000
**** DONE Equality [★]

+ Write an expression that compares ~42~~ to ~42~ using structural equality
+ Write an expression that compares ~"hi"~ to ~"hi"~ using structural
  equality. What is the result?
+ Write an expression that compares ~"hi"~ to ~"hi"~ using physical
  equality. What is the result?


Structural equality is compared with ~=~ (or ~<>~ for inequality)

#+begin_src ocaml
  42 = 42
#+end_src

#+RESULTS:
: true

#+begin_src ocaml
  "hi" = "hi"
#+end_src

#+RESULTS:
: true

Physical equality is compared with ~==~ and ~!=~.
#+begin_src ocaml
  "hi" == "hi"
#+end_src

#+RESULTS:
: false

structural equality is closer to the mathematical notion of equality,
but physical equality is closer to "are these the same object in
memory?". Probably usually better to use ~=~.
**** DONE Assertions [★]

+ Enter ~assert true;;~ into utop and see what happens.
+ Enter ~assert false;;~ into utop and see what happens.
+ Write an expression that asserts 2110 is not (structurally) equal
  to 3110.

  ~assert true;;~ seems to do "nothing" with type unit. Assert false
  throws an exception (Assert_failure)

  #+begin_src ocaml
    assert (2110 <> 3110);;
  #+end_src

  #+RESULTS:
  : ()
**** DONE If [★]

Write an if expression that evaluates to 42 if 2 is greater than 1 and
otherwise evaluates to 7.

#+begin_src ocaml
  if 2 > 1 then 42 else 7;;
#+end_src

#+RESULTS:
: 42
**** DONE Double fun [★]

Using the increment function from above as a guide, define a function
double that multiplies its input by 2. For example, double 7 would
be 14. Test your function by applying it to a few inputs. Turn those
test cases into assertions.

#+begin_src ocaml results: verbatim

  let double x = 2 * x;;

  double 7;;
  double 100;;
  double (-5);;

  assert (double 20 = 2*20);;
  assert (double 0 = 0)
#+end_src

#+RESULTS:
: ()

**** DONE More fun [★★]

+ Define a function that computes the cube of a floating-point number. Test your function by applying it to a few inputs.
+ Define a function that computes the sign (1, 0, or -1) of an integer. Use a nested if expression. Test your function by applying it to a few inputs.
+ Define a function that computes the area of a circle given its
  radius. Test your function with assert.

  #+begin_src ocaml
    let cube x = x *. x *. x;;

    cube 1.5;;
    cube 2.1;;
    cube Float.pi;;
  #+end_src

  #+RESULTS:
  : 31.006276680299816

#+begin_src ocaml

    let sgn x = match x with
      | 0 -> 0
      | x -> if x > 0 then 1 else -1;;

    sgn 2;;
    sgn 4;;
    sgn (-1 * 5);;
    sgn 0
#+end_src

#+RESULTS:
: 0

#+begin_src ocaml
  let area r =
    let pi = Float.pi in
    pi *. r *. r;;

  area 1.0;;
  area 2.0;;

assert (area 1.0 -. Float.pi < 1e-5)
#+end_src

#+RESULTS:
: ()

**** DONE RMS [★★]

Define a function that computes the root mean square of two
numbers—i.e.
\[\sqrt{x^2 + y^2}\]
Test your function with assert.

#+begin_src ocaml
  let rms x y = Float.sqrt(x *. x +. y *. y);;

  rms 3. 4.;;
  rms 5. 12.;;
  rms 7399. 10200.;;
#+end_src


test with pythagorean triples

#+begin_src ocaml
    let rmstest s t =
      let a = 2. *. s *. t in
      let b = s *. s -. t *. t in
      let c = s *. s +. t *. t in
      assert (rms a b -. c < 1e-8);;

    rmstest 10. 21.;;
    rmstest 1000. 3201.;;
#+end_src

#+RESULTS:
: ()

**** DONE date fun [★★★]

Define a function that takes an integer d and string m as input and returns true just when d and m form a valid date. Here, a valid date has a month that is one of the following abbreviations: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sept, Oct, Nov, Dec. And the day must be a number that is between 1 and the minimum number of days in that month, inclusive. For example, if the month is Jan, then the day is between 1 and 31, inclusive, whereas if the month is Feb, then the day is between 1 and 28, inclusive.

How terse (i.e., few and short lines of code) can you make your
function? You can definitely do this in fewer than 12 lines.

(it's not clear to me why this is a "three star" exercise. Am I
supposed to to this with a hash table or something?
#+begin_src ocaml
  let valid_date d m =
    match d with
    | "Feb" -> m <= 28
    | "Sept" | "Apr" | "Jun" | "Nov" -> m <= 30
    | "Jan" | "Mar" | "May" | "Jul" | "Aug" | "Oct" | "Dec" -> m <= 31
    | _ -> false;;

  valid_date "Apr" 20
#+end_src

#+RESULTS:
: true

**** DONE fib [★★]

Define a recursive function ~fib : int -> int~, such that ~fib n~ is
the nth number in the Fibonacci sequence, which is 1, 1, 2, 3, 5, 8,
13, … That is

+ ~fib 1 = 1~
+ ~fib 2 = 1~
+ ~fib n = fib (n-1) + fib (n-2)~ for ~n > 2~

#+begin_src ocaml
  let rec fib n = match n with
    | 1 | 2 -> 1
    | n -> fib (n-1) + fib (n-2);;

  List.map fib [1;2;3;4;5;6;7;8;9;10]
#+end_src

  #+RESULTS:
  | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 |

**** DONE fib fast [★★★]

How quickly does your implementation of fib compute the 50th Fibonacci
number? If it computes nearly instantaneously, congratulations! But
the recursive solution most people come up with at first will seem to
hang indefinitely. The problem is that the obvious solution computes
subproblems repeatedly. For example, computing fib 5 requires
computing both fib 3 and fib 4, and if those are computed separately,
a lot of work (an exponential amount, in fact) is being redone.

#+begin_src ocaml results: verbatim
    let fibtimer n = 
      let t1 = Sys.time() in
      let fn = fib n in
      let t2 = Sys.time() in
      let output = "found fib "
                   ^ (string_of_int n)
                   ^ " = "
                   ^ (string_of_int fn)
                   ^ " in "
                   ^ (string_of_float (t2 -. t1))
                   ^ " seconds." in
      print_endline output;;

    fibtimer 50;;
#+end_src

#+RESULTS:
: ()

Prints ~found fib 50 = 12586269025 in 257.446328 seconds~. Slow.

#+begin_src ocaml
    let fib_fast n =
      let rec fibhelp a b n = match n with
        | 1 -> a
        | n -> fibhelp b (a+b) (n-1) in
      fibhelp 1 1 n;;

  let fibfasttimer n = 
    let t1 = Sys.time() in
    let fn = fib_fast n in
    let t2 = Sys.time() in
    let output = "found fib_fast "
                 ^ (string_of_int n)
                 ^ " = "
                 ^ (string_of_int fn)
                 ^ " in "
                 ^ (string_of_float (t2 -. t1))
                 ^ " seconds." in
    print_endline output;;

  fibfasttimer 50;;
#+end_src

#+RESULTS:
: ()

Prints ~found fib_fast 50 = 12586269025 in 4.99999998738e-06
seconds.~, much faster.

What is the first value of n for which fib_fast n is negative,
indicating that integer overflow occurred?

#+begin_src ocaml
  let first_overflow =
    let rec next_neg_fib n =
      if (fib_fast n < 0) then (n) else (next_neg_fib (n+1)) in
    next_neg_fib 1
#+end_src

#+RESULTS:
: 91

**** DONE poly types [★★★]

What is the type of each of the functions below? You can ask the
toplevel to check your answers

+ let f x = if x then x else x
+ let g x y = if y then x else x
+ let h x y z = if x then y else z
+ let i x y z = if x then y else y

  ~let f x = if x then x else x~: Since ~x~ is being passed as the first
  argument to the ternary if-then-else, it has to be a boolean. Since
  the output is always ~x~, the output of ~f~ will be boolean. So ~f~
  is a function ~bool -> bool~.

  ~let g x y = if y then x else x~: Here, ~y~ needs to be boolean. But
  ~x~ can have arbitrary type ~T~. The output of the function will
  have the same type as ~x~ (in fact it will be ~x~), so ~g~ is a function
  that takes an argument of type ~T~ and an argument of type bool and
  returns an output of type ~T~. i.e. ~g: T -> bool -> T~. Ocaml uses
  ~'a~ for this type variable.

  ~let h x y z = if x then y else z~: Again, ~x~ needs to have type
  ~bool~. Since the ~then ()~ and ~else ()~ branches needs to have the
  same output type, ~y~ and ~z~ need to have the same arbitrary type
  ~T~. So ~h : bool -> T -> T -> T~

  ~let i x y z = if x then y else y~: Here, ~x~ need to have type
  ~bool~. ~y~ can have arbitrary type ~T1~, and ~z~ can have arbitrary
  type ~T2~. The output is always ~y~, which will have type ~T1~. So
  ~i: bool -> T1 -> T2 -> T1~

**** DONE Divide [★★]

Write a function divide : numerator:float -> denominator:float ->
float. Apply your function.

#+begin_src ocaml
    let divide num denom =
      let q = num /. denom in
      match q with
      | q when q = infinity -> raise Division_by_zero
      | q when q = neg_infinity -> raise Division_by_zero
      | q when compare q nan = 0 -> raise Division_by_zero
      | q -> q;;

    divide 0. 0.
#+end_src

#+RESULTS:
: Exception: Division_by_zero.

(weirdly, ~nan = nan~ is false, so you need to use the compare in that
case)

**** DONE Associativity [★★]

Suppose that we have defined ~let add x y = x + y~. Which of the
following produces an integer, which produces a function, and which
produces an error? Decide on an answer, then check your answer in the
toplevel.

+ ~add 5 1~
  This is ~add~ applied to two arguments. It evaluates to ~~5+1 = 6~. 
+ ~add 5~
  This is ~add~ applied to one argument. It is the "add five" function.
+ ~(add 5) 1~
  This is the "add five" function, appled to ~1~. It evaluates to ~6~.
+ ~add (5 1)~
  This will produce an error. In fact, just (5 1) by itself will
  produce an error, since ~5~ is not a function, so it can't be
  applied to ~1~.

**** DONE Average [★★]

Define an infix operator ~+/.~ to compute the average of two
floating-point numbers. For example,

+ ~1.0 +/. 2.0 = 1.5~
+ ~0. +/. 0. = 0.~

  #+begin_src ocaml
    let (+/.) a b = (a +. b) /. 2.;;

     1.0 +/. 2.0;;
     0. +/. 0. ;;
  #+end_src

  #+RESULTS:
  : 0

**** DONE Hello World [★]

Type the following in utop, and notice the difference in output from
each:

+ ~print_endline "Hello world!";;~
  Prints the string, with a carriage return at the end. Has type
  ~unit~. Output looks like:

  #+begin_export ascii
  Hello world!
  - : unit = ()
  #+end_export
  
+ ~print_string "Hello world!";;~
  Prints the string with no newline. Has type unit. Output looks like:

  #+begin_export ascii
  Hello world!- : unit = ()
  #+end_export

*** TODO 3.14 Data and Types - Exercises
**** DONE List Expressions [★]
+ Construct a list that has the integers 1 through 5 in it. Use the
  square bracket notation for lists.
  
  #+begin_src ocaml
    let l1 = [1;2;3;4;5];;
  #+end_src

  #+RESULTS:
  | 1 | 2 | 3 | 4 | 5 |
  
+ Construct the same list, but do not use the square bracket
  notation. Instead use ~::~ and ~[]~.

  #+begin_src ocaml
    let l2 = 1::2::3::4::5::[];;
  #+end_src

  #+RESULTS:
  | 1 | 2 | 3 | 4 | 5 |

+ Construct the same list again. This time, the following expression
  must appear in your answer: ~[2; 3; 4]~. Use the @ operator, and do
  not use ~::~

  #+begin_src ocaml
    let l3 = [1] @ [2;3;4] @ [5];;
  #+end_src

  #+RESULTS:
  | 1 | 2 | 3 | 4 | 5 |

**** DONE Product [★★]

Write a function that returns the product of all the elements in a
list. The product of all the elements of an empty list is ~1~.

#+begin_src ocaml

  let list_product l =
    let rec list_product_acc p l = match l with
      | [] -> p
      | x :: xs -> list_product_acc (p*x) xs in
    list_product_acc 1 l;;

  list_product (l1 @ l2 @ l3)
#+end_src

#+RESULTS:
: 1728000

**** DONE concat [★★]

Write a function that concatenates all the strings in a list. The
concatenation of all the strings in an empty list is the empty string
"".

#+begin_src ocaml

    let list_concat l =
      let rec list_concat_acc s l = match l with
        | [] -> s
        | x :: xs -> list_concat_acc (s^x) xs in
      list_concat_acc "" l;;

    list_concat ["Hel"; "lo"; ","; " ";"world";"!"]
#+end_src

#+RESULTS:
: Hello, world!

**** TODO product test [★★]

Unit test the function product that you wrote in an exercise above.

**** DONE Patterns [★★★]

Using pattern matching, write three functions, one for each of the following properties. Your functions should return true if the input list has the property and false otherwise.

+ the list’s first element is "bigred"

  #+begin_src ocaml
    let bigred l = match l with
    | "bigred" :: xs -> true
    | _ -> false;;

    bigred ["smallred"];;
    bigred ["bigred";"x";"y";"z"]
  #+end_src

  #+RESULTS:
  : true

(I'm not sure how to make this polymorphic: if the first element is an
integer, I get a type error

+ the list has exactly two or four elements; do not use the length
  function

  #+begin_src ocaml
        let two_or_four l = match l with
          | x::y::[] -> true
          | x::y::z::w::[] -> true
          | _ -> false;;

        two_or_four [1;2;3;4];;
        two_or_four ["a";"b"]
  #+end_src

  #+RESULTS:
  : true
  
+ the first two elements of the list are equal

  #+begin_src ocaml
        let first_two_equal l = match l with
        | x::y::xs when x = y -> true
        | _ -> false;;

        first_two_equal [1;2;3];;
        first_two_equal [[1];[1];[1;2]];;
        first_two_equal [[];[];[1;2]];;
        first_two_equal ([[]]::[[]]::[]);;
  #+end_src

  #+RESULTS:
  : true
  
**** DONE Library [★★★]

Consult the List standard library to solve these exercises:

+ Write a function that takes an int list and returns the fifth
  element of that list, if such an element exists. If the list has
  fewer than five elements, return 0. Hint: List.length and List.nth.

  #+begin_src ocaml
        let fifth_element l =
          if (List.length l >= 5) then (List.nth l 4) else (0);;

        fifth_element [1;2;3;4;5;6;7;8;9];;
        fifth_element [8;7;6;5;4];;
        fifth_element [1]
  #+end_src

  #+RESULTS:
  : 0

+ Write a function that takes an int list and returns the list sorted
in descending order. Hint: List.sort with Stdlib.compare as its
first argument, and List.rev.
  
#+begin_src ocaml
  let descending_sort l = l
                    |> List.sort Stdlib.compare
                    |> List.rev;;

  descending_sort [1;4;3;2;3;4;3;1;10;23;14]
#+end_src

#+RESULTS:
| 23 | 14 | 10 | 4 | 4 | 3 | 3 | 3 | 2 | 1 | 1 |

**** TODO Library Test [★★★]

Write a couple OUnit unit tests for each of the functions you wrote in
the previous exercise

**** DONE Library Puzzle [★★★]

+ Write a function that returns the last element of a list. Your
  function may assume that the list is non-empty. Hint: Use two
  library functions, and do not write any pattern matching code of
  your own.

#+begin_src ocaml
  let last_element l = List.nth l (List.length l - 1);;

  last_element [1;4;3;2;3;7];;
#+end_src

#+RESULTS:
: 7

+ Write a function ~any_zeroes : int list -> bool~ that returns ~true~
  if and only if the input list contains at least one ~0~. Hint: use
  one library function, and do not write any pattern matching code
  of your own.

  #+begin_src ocaml
        let any_zeroes l = List.exists ((=) 0) l;;

        any_zeroes [1;2;3;4;10];;
        any_zeroes [1;2;3;-1;-2;-10];;
        any_zeroes [];;
        any_zeroes [1;1;1;1;0;1;1;2;2;3;3;4]
  #+end_src

  #+RESULTS:
  : true

**** DONE Take Drop [★★★]

+ Write a function take : int -> 'a list -> 'a list such that take n
  lst returns the first n elements of lst. If lst has fewer than n
  elements, return all of them.

#+begin_src ocaml

    let rec take n l = match n with
      | 0 -> []
      | n -> (match l with
              | x :: xs -> x::(take (n-1) xs)
              | [] -> []);;

    take 2 [5;4;3;2;1];;
    take 3 [1;2];;
    take 0 [1;2];;
    take 0 [];;
#+end_src

#+RESULTS:
: []

+ Write a function drop : int -> 'a list -> 'a list such that drop n
  lst returns all but the first n elements of lst. If lst has fewer
  than n elements, return the empty list.

  #+begin_src ocaml
    let rec drop n l = match n with
    | 0 -> l
    | n -> (match l with
          | x :: xs -> drop (n-1) xs
          | [] -> []);;

    drop 3 [1;2;3;4;5;6;7;8];;
    drop 2 [1];;
    drop 3 [5;4;4];;
    drop 0 [1;2;3]
  #+end_src

  #+RESULTS:
  | 1 | 2 | 3 |
 
**** DONE Take Drop Tail [★★★★]

Revise your solutions for take and drop to be tail recursive, if they
aren’t already. Test them on long lists with large values of n to see
whether they run out of stack space. To construct long lists, use the
~--~ operator from the lists section.

Here's the ~--~ operator:

#+begin_src ocaml
let rec from i j l = if i > j then l else from i (j - 1) (j :: l);;

let ( -- ) i j = from i j [];;

let long_list = 0 -- 1_000_000;;
#+end_src

#+RESULTS:
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 123 | 124 | 125 | 126 | 127 | 128 | 129 | 130 | 131 | 132 | 133 | 134 | 135 | 136 | 137 | 138 | 139 | 140 | 141 | 142 | 143 | 144 | 145 | 146 | 147 | 148 | 149 | 150 | 151 | 152 | 153 | 154 | 155 | 156 | 157 | 158 | 159 | 160 | 161 | 162 | 163 | 164 | 165 | 166 | 167 | 168 | 169 | 170 | 171 | 172 | 173 | 174 | 175 | 176 | 177 | 178 | 179 | 180 | 181 | 182 | 183 | 184 | 185 | 186 | 187 | 188 | 189 | 190 | 191 | 192 | 193 | 194 | 195 | 196 | 197 | 198 | 199 | 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214 | 215 | 216 | 217 | 218 | 219 | 220 | 221 | 222 | 223 | 224 | 225 | 226 | 227 | 228 | 229 | 230 | 231 | 232 | 233 | 234 | 235 | 236 | 237 | 238 | 239 | 240 | 241 | 242 | 243 | 244 | 245 | 246 | 247 | 248 | 249 | 250 | 251 | 252 | 253 | 254 | 255 | 256 | 257 | 258 | 259 | 260 | 261 | 262 | 263 | 264 | 265 | 266 | 267 | 268 | 269 | 270 | 271 | 272 | 273 | 274 | 275 | 276 | 277 | 278 | 279 | 280 | 281 | 282 | 283 | 284 | 285 | 286 | 287 | 288 | 289 | 290 | 291 | 292 | 293 | 294 | 295 | 296 | 297 | 298 | ... |

#+begin_src ocaml
    let take n l =
      let rec take_tr n l h = match n with
        | 0 -> h
        | n -> (match l with
               | [] -> h
               | x :: xs -> take_tr (n-1) (xs) (x :: h)) in
      List.rev (take_tr n l []);;

    List.length (take 2000000 (6 -- 4000000))
#+end_src

#+RESULTS:
: 2000000

I am not sure I needed to use ~List.rev~ here. That seems like a cost
that should be avoided, if possible. It also means I'm not 100% sure
this is tail recursive unless I check whether or not ~List.rev~ is
tail recursive. The documentation doesn't say whether it is or isn't.

#+begin_src ocaml
    let rec drop n l =
      match n with
      | 0 -> l
      | n -> (match l with
             | [] -> []
             | x :: xs -> drop (n-1) xs);;

    drop 999999 (1 -- 1000000);;
#+end_src

#+RESULTS:
| 1000000 |

Still not clear how to check whether or not something is tail
recursive. It seems like the givaway is when the recursive call is
part of a bigger expression instead of just on its own. I also think
that ~drop 999999 (1 -- 1000000)~ would have stack overflowed if this
wasn't tail recursive.

**** DONE Unimodal [★★★]

Write a function is_unimodal : int list -> bool that takes an integer
list and returns whether that list is unimodal. A unimodal list is a
list that monotonically increases to some maximum value then
monotonically decreases after that value. Either or both segments
(increasing or decreasing) may be empty. A constant list is unimodal,
as is the empty list.

#+begin_src ocaml
    let rec is_unimodal l =
      let rec is_nonincreasing l = match l with
      | [] -> true
      | x :: [] -> true
      | a :: b :: tail -> if (a < b)
                          then (false)
                          else (is_nonincreasing (b :: tail)) in
      match l with
      | [] -> true
      | x :: [] -> true
      | a :: b :: [] -> true
      | a :: b :: tail -> if (a <= b)
                          then (is_unimodal (b :: tail))
                          else (is_nonincreasing (b :: tail));;

    is_unimodal [1;2;2;2;3;3;2;2];;
    is_unimodal [1;2;3;4;4;4;5];;
    is_unimodal [6;5;4;3;2;1];;
    is_unimodal [1;2;3;3;2;1;2];;
    is_unimodal [1;1;1;1;1];;
    is_unimodal [0;0;0;0;0;0;0;0;1];;
    is_unimodal [1;0;0;0;0;0;0;0;0;0];;
    is_unimodal [4]
#+end_src

#+RESULTS:
: true

**** DONE Power set [★★★]

Write a function ~powerset : int list -> int list list~ that takes a
set ~S~ represented as a list and returns the set of all subsets of
S. The order of subsets in the powerset and the order of elements in
the subsets do not matter.

Hint: Consider the recursive structure of this problem. Suppose you
already have ~p~, such that ~p = powerset s~. How could you use ~p~ to
compute ~powerset (x :: s)~?

#+begin_src ocaml :results verbatim
  let rec powerset lst = match lst with
    | [] -> [[]]
    | x :: xs -> let p = powerset xs in
                 (List.map (fun s -> x::s) p) @ p;;
  List.length (powerset [1;2;3;4;5;6;7])
#+end_src

#+RESULTS:
: - : int = 128

**** DONE Print int list rec [★★]

Write a function print_int_list : int list -> unit that prints its
input list, one number per line. For example, print_int_list [1; 2; 3]
should result in this output:

#+begin_example
1
2
3
#+end_example

#+begin_src ocaml :results verbatim
    let rec print_int_list = function
      | [] -> ()
      | x :: xs -> (x |> string_of_int |> print_endline) ; print_int_list xs;;

    print_int_list [1;2;3;4;5;5;6]
#+end_src

#+RESULTS:
: 1
: 2
: 3
: 4
: 5
: 5
: 6
: - : unit = ()

**** DONE Print int list iter [★★]

Write a function ~print_int_list' : int list -> unit~ whose
specification is the same as ~print_int_list~. Do not use the keyword
~rec~ in your solution, but instead to use the ~List~ module function
~List.iter~.

#+begin_src ocaml :results verbatim
  let print_int_list lst = 
    List.iter (fun e -> e |> string_of_int |> print_endline) lst;;

  print_int_list [1;2;3;4;5;5;6];;
#+end_src

#+RESULTS:
: 1
: 2
: 3
: 4
: 5
: 5
: 6
: - : unit = ()

**** DONE Student [★★]

Assume the following type definition:

#+begin_src ocaml
  type student = {first_name : string; last_name : string; gpa : float}
#+end_src

#+RESULTS:
: type student = { first_name : string; last_name : string; gpa : float; }

Give OCaml expressions that have the following types:

+ ~student~

  #+begin_src ocaml
    let s = {first_name = "John";
             last_name = "Smith";
             gpa = 3.9}
  #+end_src

  #+RESULTS:
  : {first_name = "John"; last_name = "Smith"; gpa = 3.9}

+ ~student -> string * string~ (a function that extracts the student’s
  name)

  #+begin_src ocaml
    let name_of_student s = (s.last_name, s.first_name);;

    name_of_student s;;
  #+end_src

  #+RESULTS:
  : ("Smith", "John")

+ ~string -> string -> float -> student~ (a function that creates a
  student record)

  (using the syntactic sugar mentioned in the chapter)
  
#+begin_src ocaml :results verbatim
  let student first_name last_name gpa = {first_name; last_name; gpa};;
#+end_src

#+RESULTS:
: val student : string -> string -> float -> student = <fun>

**** DONE Pokerecord [★★]

Here is a variant that represents a few Pokémon types:

#+begin_src ocaml
  type poketype = Normal | Fire | Water
#+end_src

#+RESULTS:
: type poketype = Normal | Fire | Water

+ Define the type ~pokemon~ to be a record with fields ~name~ (a
  string), ~hp~ (an integer), and ~ptype~ (a poketype).

  #+begin_src ocaml
    type pokemon = {name:string; hp:int; ptype:poketype}
  #+end_src

  #+RESULTS:
  : type pokemon = { name : string; hp : int; ptype : poketype; }

+ Create a record named ~charizard~ of type ~pokemon~ that represents
  a Pokémon with 78 HP and Fire type.

  #+begin_src ocaml
    let charizard = {name = "charizard";
                     hp = 78;
                     ptype = Fire}
  #+end_src

  #+RESULTS:
  : {name = "charizard"; hp = 78; ptype = Fire}

+ Create a record named ~squirtle~ of type ~pokemon~ that represents a Pokémon with 44 HP and Water type.

  #+begin_src ocaml
    let squirtle = {name = "squirtle";
                    hp = 44;
                     ptype = Water}
  #+end_src

  #+RESULTS:
  : {name = "squirtle"; hp = 44; ptype = Water}
  
**** DONE Safe hd and tl [★★]

Write a function ~safe_hd : 'a list -> 'a option~ that returns ~Some
x~ if the head of the input list is ~x~, and ~None~ if the input list
is empty.


Also write a function ~safe_tl : 'a list -> 'a list option~ that
returns the tail of the list, or ~None~ if the list is empty.

#+begin_src ocaml
    let safe_hd = function
      | [] -> None
      | x :: xs -> Some x;;

    safe_hd [4;2;3];;
    safe_hd [1];;
    safe_hd [];;
#+end_src

#+RESULTS:
: None

#+begin_src ocaml
    let safe_tl = function
      | [] -> None
      | x :: xs -> Some xs;;

    safe_tl [4;2;3];;
    safe_tl [1];;
    safe_tl [];;
#+end_src

#+RESULTS:
: None

**** DONE Pokefun [★★★]

Write a function ~max_hp : pokemon list -> pokemon option~ that, given
a list of ~pokemon~, finds the Pokémon with the highest HP.

#+begin_src ocaml
  let max_hp lst =
    let rec max_hp_acc m lst = match lst with
    | [] -> m
    | x :: xs -> if (x.hp > m)
                 then (max_hp_acc x.hp xs)
                 else (max_hp_acc m xs) in
    match lst with
    | [] -> None
    | x :: xs -> let m = x.hp in Some (max_hp_acc m xs);;

  max_hp [charizard; squirtle];;
  max_hp []
#+end_src

#+RESULTS:
: None

**** DONE Date before [★★]

Define a date-like triple to be a value of type ~int * int *
int~. Examples of date-like triples include ~(2013, 2, 1)~ and ~(0, 0,
1000)~. A date is a date-like triple whose first part is a positive
year (i.e., a year in the common era), second part is a month between
1 and 12, and third part is a day between 1 and 31 (or 30, 29, or 28,
depending on the month and year). (2013, 2, 1) is a date; (0, 0, 1000)
is not.

Write a function ~is_before~ that takes two dates as input and
evaluates to ~true~ or ~false~. It evaluates to true if the first
argument is a date that comes before the second argument. (If the two
dates are the same, the result is false.)

Your function needs to work correctly only for dates, not for
arbitrary date-like triples. However, you will probably find it easier
to write your solution if you think about making it work for arbitrary
date-like triples. For example, it’s easier to forget about whether
the input is truly a date, and simply write a function that claims
(for example) that January 100, 2013 comes before February 34,
2013—because any date in January comes before any date in February,
but a function that says that January 100, 2013 comes after February
34, 2013 is also valid. You may ignore leap years.

(I think this isn't the "right" way to do this. Need to go back
through the chapter and see if I missed anything.

#+begin_src ocaml
  type date_like_triple = {year : int;
                           month : int;
                           day : int};;

  let is_before d1 d2 =
    let (y1, m1, d1, y2, m2, d2) = (d1.year,
                                    d1.month,
                                    d1.day,
                                    d2.year,
                                    d2.month,
                                    d2.day) in
    if y1 < y2 then true
    else if y1 > y2 then false
    else if m1 < m2 then true
    else if m1 > m2 then false
    else if d1 < d2 then true
    else if d1 >= d2 then false
    else false;;

  let date1 = {year=1988;month=6;day=22};;
  let date2 = {year=1986;month=7;day=14};;
  is_before date1 date2
#+end_src

#+RESULTS:
: false

**** DONE Earliest date [★★★]

Write a function ~earliest : (int*int*int) list -> (int * int * int)
option~. It evaluates to ~None~ if the input list is empty, and to
~Some d~ if ~date d~ is the earliest date in the list. Hint: use
~is_before~.

As in the previous exercise, your function needs to work correctly
only for dates, not for arbitrary date-like triples

#+begin_src ocaml
  let earliest lst =
    let rec earliest_carry d lst = match lst with
      | [] -> d
      | x :: xs -> if (is_before x d)
                   then (earliest_carry x xs)
                   else (earliest_carry d xs) in
    match lst with
    | [] -> None
    | x :: xs -> Some (earliest_carry x xs);;

  earliest [date1; date2]
#+end_src

#+RESULTS:
: Some {year = 1986; month = 7; day = 14}

**** DONE Assoc list [★]

Use the functions ~insert~ and ~lookup~ from the section on association
lists to construct an association list that maps the integer ~1~ to the
string ~“one”~, ~2~ to ~“two”~, and ~3~ to ~“three”~. Lookup the key ~2~. Lookup
the key ~4~.

Here are ~insert~ and ~lookup~:

#+begin_src ocaml
  let insert k v lst = (k, v) :: lst

  let rec lookup k = function
    | [] -> None
    | (k', v) :: t -> if k = k' then Some v else lookup k t
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml
    let assoc_list =
      []
      |> insert 1 "one"
      |> insert 2 "two"
      |> insert 3 "three";;

    lookup 2 assoc_list;;
    lookup 4 assoc_list;;
#+end_src

#+RESULTS:
: None

**** DONE Cards [★★]

+ Define a variant type suit that represents the four suits, ♣ ♦ ♥ ♠,
  in a standard 52-card deck. All the constructors of your type should
  be constant.

#+begin_src ocaml
    type suit =
    | Hearts
    | Clubs
    | Diamonds
    | Spades
#+end_src

#+RESULTS:
: type suit = Clubs | Diamonds | Hearts | Spades

+ Define a type rank that represents the possible ranks of a card: 2,
  3, …, 10, Jack, Queen, King, or Ace. There are many possible
  solutions; you are free to choose whatever works for you. One is to
  make rank be a synonym of int, and to assume that Jack=11, Queen=12,
  King=13, and Ace=1 or 14. Another is to use variants.

#+begin_src ocaml
  type face =
    | King
    | Queen
    | Jack

  type rank =
    | Number of int
    | Face of face
#+end_src

#+RESULTS:
: type face = King | Queen | Jack
: type rank = Number of int | Face of face

+ Define a type card that represents the suit and rank of a single
  card. Make it a record with two fields.

  #+begin_src ocaml
    type card = {rank : rank; suit : suit}
  #+end_src

  #+RESULTS:
  : type card = { rank : rank; suit : suit; }

+ Define a few values of type card: the Ace of Clubs, the Queen of
  Hearts, the Two of Diamonds, the Seven of Spades.

#+begin_src ocaml
  let ace_of_clubs = {rank = Number 1;
                      suit = Clubs};;

  let queen_of_hearts = {rank = Face Queen;
                         suit = Hearts}

  let two_of_diamonds = {rank = Number 2;
                         suit = Diamonds};;

  let seven_of_spades = {rank = Number 7;
                         suit = Spades};;
#+end_src

#+RESULTS:
: {rank = Number 7; suit = Spades}

**** DONE Matching [★]

For each pattern in the list below, give a value of type ~int option
list~ that does not match the pattern and is not the empty list, or
explain why that’s impossible.

1. ~Some x :: tl~

   ~[None]~ does not match, since the head does not match
   
2. ~[Some 3110; None]~

   ~[None]~ does not match, since the head does not match. Also, ~[Some
   3110; Some 3110]~ will not match, since the second element is not
   ~None~.
   
3. ~[Some x; _]~

   Again, ~[Some x; None; None]~ does not match. It's too long.
   
4. ~h1 :: h2 :: tl~

   Any list of length ~2~ or greater will match this pattern. But
   ~[None]~ does not match it.
   
5. ~h :: tl~

   This pattern matches every list except the empty list, so we can't
   match it with a nonempty list.
**** DONE Quadrant [★★]

Complete the ~quadrant~ function below, which should return the quadrant
of the given ~x, y~ point according to the diagram on the right
(borrowed from Wikipedia). Points that lie on an axis do not belong to
any quandrant. Hints: (a) define a helper function for the sign of an
integer, (b) match against a pair.

#+begin_src ocaml
  type quad = I | II | III | IV
  type sign = Neg | Zero | Pos

  let sign (x:int) : sign =
    match x with
    | x when x > 0 -> Pos
    | x when x < 0 -> Neg
    | _ -> Zero

  let quadrant : int*int -> quad option = fun (x,y) ->
    match (sign x, sign y) with
      | (Pos, Pos) -> Some I
      | (Neg, Pos) -> Some II
      | (Neg, Neg) -> Some III
      | (Pos, Neg) -> Some IV
      | _ -> None;;

  quadrant (13,-58);;
#+end_src

#+RESULTS:
: Some IV

**** DONE Quadrant when [★★]

Rewrite the quadrant function to use the when syntax. You won’t need
your helper function from before.

#+begin_src ocaml
  let quadrant_when : int*int -> quad option = function
      | (x,y) when x > 0 && y > 0 -> Some I
      | (x,y) when x < 0 && y > 0 -> Some II
      | (x,y) when x < 0 && y < 0 -> Some III
      | (x,y) when x > 0 && y < 0 -> Some IV
      | _ -> None;;

  quadrant_when (13,-58)
#+end_src

#+RESULTS:
: Some IV

**** DONE Depth [★★]

Write a function ~depth : 'a tree -> int~ that returns the number of
nodes in any longest path from the root to a leaf. For example, the
depth of an empty tree (simply ~Leaf~) is ~0~, and the depth of tree
~t~ above is ~3~. Hint: there is a library function ~max : 'a -> 'a ->
'a~ that returns the maximum of any two values of the same type.

#+begin_src ocaml
  type 'a tree =
  | Leaf
  | Node of 'a * 'a tree * 'a tree
#+end_src

#+RESULTS:
: type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree

Here's the tree from 3.11.1:

#+begin_src ocaml
(* the code below constructs this tree:
         4
       /   \
      2     5
     / \   / \
    1   3 6   7
*)
let t =
  Node(4,
    Node(2,
      Node(1, Leaf, Leaf),
      Node(3, Leaf, Leaf)
    ),
    Node(5,
      Node(6, Leaf, Leaf),
      Node(7, Leaf, Leaf)
    )
  )
#+end_src

#+RESULTS:
: Node (4, Node (2, Node (1, Leaf, Leaf), Node (3, Leaf, Leaf)),
:    Node (5, Node (6, Leaf, Leaf), Node (7, Leaf, Leaf)))

#+begin_src ocaml
    let depth t =
      let rec depth_tr d t = match t with
      | Leaf -> d
      | Node (x, left, right) -> max (depth_tr (d+1) left) (depth_tr (d+1) right) in
    depth_tr 0 t;;

    depth Leaf;;
    depth (Node(1, Leaf, Node(1, Leaf, Leaf)));;
    depth t
#+end_src

#+RESULTS:
: 3

**** DONE Shape [★★★]

Write a function ~same_shape : 'a tree -> 'b tree -> bool~ that
determines whether two trees have the same shape, regardless of
whether the values they carry at each node are the same. Hint: use a
pattern match with three branches, where the expression being matched
is a pair of trees.

#+begin_src ocaml
    let rec same_shape t1 t2 = match (t1, t2) with
      | (Leaf, Leaf) -> true
      | (Node(_, left1, right1), Node(_, left2, right2)) -> ((same_shape left1 left2) && (same_shape right1 right2))

      | _ -> false;;

    same_shape (Node(4,t,t)) (Node(1, t, t));;
#+end_src

#+RESULTS:
: true

**** DONE List max exn [★★]

Write a function ~list_max : int list -> int~ that returns the maximum integer in a list, or raises ~Failure "list_max"~ if the list is empty.

#+begin_src ocaml
      let rec list_max_exn lst =
        let rec list_max_exn_acc m lst = match lst with
          | x :: xs -> if (x > m)
                       then (list_max_exn_acc x xs)
                       else (list_max_exn_acc m xs)
          | [] -> m in
      match List.hd lst with
      | exception (_) -> failwith "list_max"
      | m -> list_max_exn_acc m (List.tl lst);;

    list_max_exn [1;2;3;4;56;6;7;6;5;4;5;0;0;0;11;12;13];;
    list_max_exn []
#+end_src

#+RESULTS:
: Exception: Failure "list_max".

There is something going on here that I don't understand. I thought
that if you had a match expression, every possible match needs to
evaluate to the same type. But in the second match expression in the
above code, the first branch looks like it has type ~exception~ while
the second has type ~int~ or maybe ~'a~.

I also got a weird warning when I matched with ~exception (Failure
"hd")~ ("fragile-literal-pattern) that went away when I changed to to
~exception (_)~, though this seems less accurate.

**** DONE List max exn string [★★]

Write a function ~list_max_string : int list -> string~ that returns a
string containing the maximum integer in a list, or the string
~"empty"~ (note, not the exception ~Failure "empty"~ but just the
string ~"empty"~) if the list is empty. Hint: ~string_of_int~ in the
standard library will do what its name suggests.

#+begin_src ocaml
        let list_max_string lst =
          let rec list_max_string_acc m lst = match lst with
            | [] -> m
            | x :: xs -> if (x > m)
                         then (list_max_string_acc x xs)
                         else(list_max_string_acc m xs) in
          match lst with
          | [] -> "empty"
          | x :: xs -> list_max_string_acc x xs |> string_of_int;;

        list_max_string [123;252435;12312;345435;123];;
        list_max_string [99999;99998];;
        list_max_string []
#+end_src

#+RESULTS:
: empty

**** TODO List max exn ounit [★]
**** TODO is_bst [★★★★]

Write a function ~is_bst : ('a*'b) tree -> bool~ that returns true if and only if the given tree satisfies the binary search tree invariant. An efficient version of this function that visits each node at most once is somewhat tricky to write. Hint: write a recursive helper function that takes a tree and either gives you (i) the minimum and maximum value in the tree, or (ii) tells you that the tree is empty, or (iii) tells you that the tree does not satisfy the invariant. Your ~is_bst~ function will not be recursive, but will call your helper function and pattern match on the result. You will need to define a new variant type for the return type of your helper function.

**** TODO Quadrant poly  [★★]
*** TODO 4.9 Higher-Order Programming - Exercises
**** DONE Twice, no arguments [★]

Consider the following definitions. Use the toplevel to determine what the types of quad and fourth are. Explain how it can be that quad is not syntactically written as a function that takes an argument, and yet its type shows that it is in fact a function.

#+begin_src ocaml :results verbatim
  let double x = 2*x
#+end_src

#+RESULTS:
: val double : int -> int = <fun>

#+begin_src ocaml :results verbatim
  let square x = x*x
#+end_src

#+RESULTS:
: val square : int -> int = <fun>

#+begin_src ocaml :results verbatim
  let twice f x = f (f x)
#+end_src

#+RESULTS:
: val twice : ('a -> 'a) -> 'a -> 'a = <fun>

#+begin_src ocaml :results verbatim
  let quad = twice double
#+end_src

~double~ is a function of type ~int -> int~, while ~twice~ is
(polymorphically) a function that takes a function of type ~T -> T~
and produces a new function of type ~T -> T~. So when applied to
~double~, it gives a new function ~int -> int~.

Can also think of it in terms of currying: ~twice f x~ means ~f (f
x)~, so ~twice f~ is a function still waiting for its last argument.

#+RESULTS:
: val quad : int -> int = <fun>

#+begin_src ocaml :results verbatim
  let fourth = twice square
#+end_src

#+RESULTS:
: val fourth : int -> int = <fun>

The same description of ~twice double~ applies to ~twice square~ as
well, since ~double~ and ~square~ have the same type.
**** DONE Mystery Operator 1 [★★]

What does the following operator do?

#+begin_src ocaml
    let ( $ ) f x = f x;;



    double $ 3 + 1;;

    ($) (double) (3 + 1) ;;

#+end_src

#+RESULTS:
: 8

~$~ is an infix operator that applies its left argument to its right
argument. So ~f $ x~ evaluates to ~f x~. But because of the precedence
of operator binding, ~double 3 + 1~ is ~(double 3) + 1~, which is
~7~. But ~double $ 3 + 1~ is ~($) (double) (3 + 1)~, which is ~8~

**** DONE Mystery Operator 2 [★★]

What does the following operator do?

#+begin_src ocaml
  let ( @@ ) f g x = x |> g |> f;;

  (String.length @@ string_of_int) 10;
#+end_src

#+RESULTS:
: Line 2, characters 0-35:
: 2 | (String.length @@ string_of_int) 10;
:     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
: Warning 10 [non-unit-statement]: this expression should have type unit.
: Line 3, characters 0-13:
: 3 | String.length string_of_int 10;;
:     ^^^^^^^^^^^^^
: Error: This function has type string -> int
:        It is applied to too many arguments; maybe you forgot a `;'.

~@@~ is an "infix" (sort of) operator, where ~f @@ g~ is a function
that, when applied to ~x~, give ~f (g x)~ (as opposed to ~f g
x~). This is function composition.

**** DONE Repeat [★★]

Generalize ~twice~ to a function ~repeat~, such that ~repeat f n x~ applies ~f~ to ~x~ a total of ~n~ times.

#+begin_src ocaml
    let rec repeat f n x = match n with
      | 0 -> x
      | n -> f (repeat f (n-1) x);;

    repeat double 10 1;;
#+end_src

#+RESULTS:
: 1024

**** DONE Product [★]

Use ~fold_left~ to write a function ~product_left~ that computes the product of a list of floats. The product of the empty list is ~1.0~. Hint: recall how we implemented sum in just one line of code in lecture.

~fold left~ is defined below. For a specific binary function ~f~, a starting
"accumulation" value ~a~ and a list like (for example) ~[1;2;3]~, it
gives ~f (f (f a 1) 2) 3~. If the binary function is multiplication
and the initial accumulation value is ~1~, you'll get the product of
the elements in the list.

#+begin_src ocaml
  let rec fold_left f acc = function
    | [] -> acc
    | h :: t -> fold_left f (f acc h) t;;

  let product_left = fold_left ( * ) 1;;

  product_left [1;2;3;4]
#+end_src

#+RESULTS:
: 24

Use ~fold_right~ to write a function ~product_right~ that computes the product of a list of floats. Same hint applies

Again, ~fold_right~ is defined below: Given ~f~, ~a~ and ~[1;2;3]~ as
above, you'd get ~f 1 (f 2 (f 3 a))~.

I think the only difference here is that you "need" (probably a way
around it though) to specificy the list argument to ~product_right~.

#+begin_src ocaml
  let rec fold_right f lst acc = match lst with
    | [] -> acc
    | h :: t -> f h (fold_right f t acc);;

  let product_right lst = fold_right ( * ) lst 1;;

  product_right [1;2;3;4;5]
#+end_src

#+RESULTS:
: <fun>

**** DONE Terse Product [★★]

How terse can you make your solutions to the ~product~ exercise?
Hints: you need only one line of code for each, and you do not need
the ~fun~ keyword. For ~fold_left~, your function definition does not
even need to explicitly take a list argument. If you use ~ListLabels~,
the same is true for ~fold_right~.

I think my product_left is about as terse as possible already. To
eliminate the argument from the left hand side of product_right, you
could do:

#+begin_src ocaml
    let rec fold_right ~fn:f ~list:lst ~a:acc = match lst with
      | [] -> acc
      | h :: t -> f h (fold_right ~fn:f ~list:t ~a:acc)

    let product_right_terse = fold_right ~fn:( * ) ~a:1;;

    product_right_terse [1;2;3;4;5;6]
#+end_src

#+RESULTS:
: 720

(should figure out exactly the syntax and conventions for labelled
argument, since I don't feel like I did this exactly the right way.)

**** DONE sum cube odd [★★]

Write a function ~sum_cube_odd n~ that computes the sum of the cubes
of all the odd numbers between ~0~ and ~n~ inclusive. Do not write any
new recursive functions. Instead, use the functionals ~map~, ~fold~,
and ~filter~, and the ~( -- )~ operator (defined in the discussion of
pipelining).

The infix range operator from earlier in the chapter:
#+begin_src ocaml
  let rec ( -- ) i j = if i > j then [] else i :: i + 1 -- j;;
#+end_src

#+begin_src ocaml

  let sum_cube_odd n =
    let odd m = m mod 2 = 1 in
    let cube x = x * x * x in
    (1 -- n)
    |> List.filter odd
    |> List.map cube
    |> List.fold_left (+) 0 ;;

  sum_cube_odd 10
#+end_src

#+RESULTS:
: 1225

**** DONE sum cube odd pipeline [★★]

Rewrite the previous function with the pipeline ~|>~ operator. (I
already used it a fair bit in the previous, But I guess with even
fewer inner ~let~ statements and more pipelininig it could be written:

#+begin_src ocaml
    let sum_cube_odd_pipeline n =
      n
      |> (--) 1
      |> List.filter (fun m -> m mod 2 = 1)
      |> List.map (fun x -> x * x * x)
      |> List.fold_left (+) 0 ;;

  sum_cube_odd_pipeline 10
#+end_src

#+RESULTS:
: 1225

**** DONE exists [★★]
Consider writing a function ~exists: ('a -> bool) -> 'a list -> bool~, such that ~exists p [a1; ...; an]~ returns whether at least one element of the list satisfies the predicate ~p~. That is, it evaluates the same as ~(p a1) || (p a2) || ... || (p an)~. When applied to an empty list, it evaluates to false.

Write three solutions to this problem, as we did above:

+ ~exists_rec~, which must be a recursive function that does not use the
  ~List~ module.

  #+begin_src ocaml :results verbatim
        let rec exists_rec p lst = match lst with
          | [] -> false
          | x :: xs -> if p x then true else exists_rec p xs;;

        let even n = n mod 2 = 0;;
        let odd n = n mod 2 = 1 || n mod 2 < 0;;

        exists_rec even [1;2;3;4;5;6;7];;
        exists_rec odd [-2;-4;-6;-8]
  #+end_src

  #+RESULTS:
  : - : bool = false
  
+ ~exists_fold~, which uses either ~List.fold_left~ or ~List.fold_right~,
  but not any other ~List~ module functions nor the ~rec~ keyword.

  #+begin_src ocaml :results verbatim
        let exists_fold p lst =
          lst |> List.fold_left (fun x y -> x || p y) false;;

        exists_fold even [1;3;5;7];;
        exists_fold odd [-2;0;2;6];;
        exists_fold even [1;2;3;4;5];;
        exists_fold even []
  #+end_src

  #+RESULTS:
  : - : bool = false

+ ~exists_lib~, which uses any combination of ~List~ module functions
  other than ~fold_left~ or ~fold_right~, and does not use the ~rec~
  keyword.

  #+begin_src ocaml
    let exists_lib p lst =
      match lst
            |> List.find_map (fun x -> if (p x)
                                       then (Some x)
                                       else (None)) with
    | Some x -> true
    | None -> false;;

    exists_lib even [1;3;5;8]
  #+end_src

  #+RESULTS:
  : true

(There are probably lots of ways to do this one)

**** TODO account balance [★★★]

Write a function which, given a list of numbers representing debits,
deducts them from an account balance, and finally returns the
remaining amount in the balance. Write three versions: fold_left,
fold_right, and a direct recursive implementation.

**** DONE library uncurried [★★]

Here is an uncurried version of ~List.nth~:

#+begin_src ocaml
  let uncurried_nth (lst, n) = List.nth lst n
#+end_src

In a similar way, write uncurried versions of these library functions:

+ ~List.append~

  #+begin_src ocaml
        let uncurried_append (l1, l2) = List.append l1 l2;;
        uncurried_append ([1;2;3],[3;4;5])

  #+end_src

  #+RESULTS:
  | 1 | 2 | 3 | 3 | 4 | 5 |

+ ~Char.compare~

  #+begin_src ocaml
        let uncurried_compare (c1, c2) = Char.compare c1 c2;;

        uncurried_compare ('a','a');;
        uncurried_compare ('a','z');;
  #+end_src

  #+RESULTS:
  : -25

+ ~Stdlib.max~

  #+begin_src ocaml
        let uncurried_max (v1, v2) = Stdlib.max v1 v2;;

        uncurried_max (15, 16)
  #+end_src

  #+RESULTS:
  : 16

**** DONE map composition [★★★]

Show how to replace any expression of the form ~List.map f (List.map g
lst)~ with an equivalent expression that calls ~List.map~ only once.

The expression

#+begin_src ocaml
  let f x = x + 1;;
  let g x = 3 * x;;
  let lst = [1;2;3;4];;
  (* The expression *)
  List.map f (List.map g lst);;
  (* Could instead be written as follows *)
  List.map (fun x -> f (g x)) lst
#+end_src

#+RESULTS:
| 4 | 7 | 10 | 13 |

**** DONE more list fun [★★★]

Write functions that perform the following computations. Each function
that you write should use one of ~List.fold~, ~List.map~ or
~List.filter~. To choose which of those to use, think about what the
computation is doing: combining, transforming, or filtering elements.

+ Find those elements of a list of strings whose length is strictly
  greater than ~3~.

#+begin_src ocaml
    let long_strings lst =
      let long_enough s = String.length s > 3 in
      List.filter long_enough lst;;

    long_strings ["a";"hello";"world";"!!!";"!";"!!!!"]
#+end_src

#+RESULTS:
| hello | world | !!!! |

+ Add ~1.0~ to every element of a list of floats.

  #+begin_src ocaml :results verbatim
    let increment_floats lst =
      lst |> List.map (fun x -> x +. 1.0);;

    increment_floats [1.;2.;3.;7.];;
  #+end_src

  #+RESULTS:
  : - : float list = [2.; 3.; 4.; 8.]

+ Given a list of strings strs and another string sep, produce the
  string that contains every element of strs separated by sep. For
  example, given inputs ["hi";"bye"] and ",", produce "hi,bye", being
  sure not to produce an extra comma either at the beginning or end of
  the result string.

  #+begin_src ocaml :results verbatim
    let delimit_strings lst sep = match lst with
    | [] -> ""
    | x :: [] -> x
    | x :: xs -> x ^ (List.fold_left (fun a b -> a ^ sep ^ b) "" xs);;

    delimit_strings ["0";"1";"2";"3";"4";"5";"6";"7";] " -- " 
  #+end_src

  #+RESULTS:
  : - : string = "0 -- 1 -- 2 -- 3 -- 4 -- 5 -- 6 -- 7"

**** DONE association list keys [★★★]

Recall that an association list is an implementation of a dictionary
in terms of a list of pairs, in which we treat the first component of
each pair as a key and the second component as a value.

Write a function ~keys: ('a * 'b) list -> 'a list~ that returns a list of the unique keys in an association list. Since they must be unique, no value should appear more than once in the output list. The order of values output does not matter. How compact and efficient can you make your solution? Can you do it in one line and linearithmic space and time? Hint: ~List.sort_uniq~.

#+begin_src ocaml
    let keys al = List.map (fun (k,v) -> k) al |> List.sort_uniq (fun k1 k2 -> if (k1 < k2) then (-1) else (if k1 > k2 then 1 else 0));;

    keys [('a',12);('b',13);('c',120);('c',14);('c',9356);('z',19);('a',53);('d',13);('e',63)]
#+end_src

#+RESULTS:
| a | b | c | d | e | z |

I don't know if this is n log n space and time. I'm also not sure if
this is the "one line" solution they're hinting at, since it's a bit
long for one line.

**** TODO valid matrix [★★★]

A mathematical matrix can be represented with lists. In row-major
representation, this matrix

\[\begin{bmatrix} 1 & 1 & 1 \\ 9 & 8 & 7 \end{bmatrix}\]

would be represented as the list ~[[1; 1; 1]; [9; 8; 7]]~. Let’s represent a row vector as an int list. For example, ~[9; 8; 7]~ is a row vector.

A valid matrix is an ~int list list~ that has at least one row, at
least one column, and in which every column has the same number of
rows. There are many values of type ~int list list~ that are invalid,
for example

+ []
+ [[1;2];[3]]

  Implement a function ~is_valid_matrix: int list list -> bool~ that
  returns whether the input matrix is valid. Unit test the function.

  #+begin_src ocaml
        let is_valid_matrix m = match m with
          | [] -> false
          | r :: rs -> (match r with
                      | [] -> false
                      | _ -> let n = List.length r in
                             if List.exists (fun r2 -> List.length r2 <> n) rs then false else true);;

        is_valid_matrix [[1;2];[3;4]];;
        is_valid_matrix [[1;2;3]];;
        is_valid_matrix [[1;2;3];[4;5]]
  #+end_src

  #+RESULTS:
  : false

  (still need to do the unit test part of this problem)
  
**** TODO row vector add [★★★]

Implement a function ~add_row_vectors: int list -> int list -> int list~
for the element-wise addition of two row vectors. For example, the
addition of ~[1; 1; 1]~ and ~[9; 8; 7]~ is ~[10; 9; 8]~. If the two vectors
do not have the same number of entries, the behavior of your function
is unspecified—that is, it may do whatever you like. Hint: there is an
elegant one-line solution using ~List.map2~. Unit test the function

#+begin_src ocaml :results verbatim
    let add_row_vectors r1 r2 = List.map2 (+) r1 r2;;

    add_row_vectors [1;2;3] [6;7;10];;
#+end_src

#+RESULTS:
: - : int list = [7; 9; 13]

**** TODO matrix add [★★★]

Implement a function ~add_matrices: int list list -> int list list ->
int list list~ for matrix addition. If the two input matrices are not
the same size, the behavior is unspecified. Hint: there is an elegant
one-line solution using ~List.map2~ and ~add_row_vectors~. Unit test the
function.

#+begin_src ocaml :results verbatim
    let add_matrices m1 m2 = List.map2 add_row_vectors m1 m2;;

    add_matrices [[0;1;2];[3;4;5];[6;7;8]] [[9;10;11];[12;13;14];[15;16;17]]
#+end_src

#+RESULTS:
: - : int list list = [[9; 11; 13]; [15; 17; 19]; [21; 23; 25]]

**** TODO matrix multiply [★★★★]

Implement a function ~multiply_matrices: int list list -> int list list
-> int list list~ for matrix multiplication. If the two input matrices
are not of sizes that can be multiplied together, the behavior is
unspecified. Unit test the function. Hint: define functions for matrix
transposition and row vector dot product.

#+begin_src ocaml :results verbatim
  let rec multiply_matrices m1 m2 =
    let dot r1 r2 = List.fold_left (+) 0 (List.map2 ( * ) r1 r2) in
    let rec row_to_column r = match r with
      | [] -> []
      | e :: es -> [e] :: row_to_column es in
    let rec transpose m = match m with
      | [] -> []
      | r :: [] -> row_to_column r
      | r :: rs -> List.map2 (@) (row_to_column r) (transpose rs) in
    let rec row_of_r_m r m = match m with
      | [] -> []
      | t :: ts -> (dot r t) :: (row_of_r_m r ts) in
    match m1 with
    | [] -> []
    | r :: rs -> (row_of_r_m r (transpose m2)) :: multiply_matrices rs m2;;

  multiply_matrices [[6;41];[1;7]] [[7;-41];[-1;6]]
#+end_src

#+RESULTS:
: - : int list list = [[1; 0]; [0; 1]]

Done, but still need to do the unit testing on all these matrix problems

*** TODO 5.11 Modular Programming - Exercises
**** DONE Complex synonym [★]

Here is a module type for complex numbers, which have a real and imaginary component:

#+begin_src ocaml
  module type ComplexSig = sig
    val zero : float * float
    val add : float * float -> float * float -> float * float
  end
#+end_src

#+RESULTS:
: module type ComplexSig =
:   sig
:     val zero : float * float
:     val add : float * float -> float * float -> float * float
:   end

Improve that code by adding ~type t = float * float~. Show how the
signature can be written more tersely because of the type synonym.

#+begin_src ocaml
  module type ComplexSig = sig
    type t = float * float
    val zero : t
    val add : t -> t -> t
  end
#+end_src

#+RESULTS:
: module type ComplexSig =
:   sig type t = float * float val zero : t val add : t -> t -> t end

**** DONE Complex encapsulation [★★]

Here is a module for the module type from the previous exercise:

#+begin_src ocaml
    module Complex : ComplexSig = struct
      type t = float * float
      let zero = (0., 0.)
      let add (r1, i1) (r2, i2) = r1 +. r2, i1 +. i2
    end
#+end_src

Investigate what happens if you make the following changes (each
independently), and explain why any errors arise:

+ remove ~zero~ from the structure

  #+begin_src ocaml
    module Complex : ComplexSig = struct
      type t = float * float
      (*let zero = (0., 0.)*)
      let add (r1, i1) (r2, i2) = r1 +. r2, i1 +. i2
    end
  #+end_src

  #+RESULTS:
  #+begin_example
  Lines 1-5, characters 30-3:
  1 | ..............................struct
  2 |   type t = float * float
  3 |   (*let zero = (0., 0.)*)
  4 |   let add (r1, i1) (r2, i2) = r1 +. r2, i1 +. i2
  5 | end..
  Error: Signature mismatch:
         Modules do not match:
           sig
             type t = float * float
             val add : float * float -> float * float -> float * float
           end
         is not included in
           ComplexSig
         The value `zero' is required but not provided
  #+end_example

The ~ComplexSig~ type, defined in the previous problem, requires a
~zero~ and an ~add~. When zero is missing, the structure defined here
is not an instance of the ComplexSig type specified. 

+ remove ~add~ from the signature
#+begin_src ocaml
    module Complex : ComplexSig = struct
      type t = float * float
      let zero = (0., 0.)
      (*let add (r1, i1) (r2, i2) = r1 +. r2, i1 +. i2*)
    end
#+end_src

#+RESULTS:
#+begin_example
Lines 1-5, characters 30-3:
1 | ..............................struct
2 |   type t = float * float
3 |   let zero = (0., 0.)
4 |   (*let add (r1, i1) (r2, i2) = r1 +. r2, i1 +. i2*)
5 | end..
Error: Signature mismatch:
       Modules do not match:
         sig type t = float * float val zero : float * float end
       is not included in
         ComplexSig
       The value `add' is required but not provided
#+end_example

Same problem as above: the type ~ComplexSig~ needs an ~add~
function. If it's missing, you don't have an instance of that type

+ change ~zero~ in the structure to ~let zero = 0, 0~

  #+begin_src ocaml
    module Complex : ComplexSig = struct
      type t = float * float
      let zero = 0, 0
      let add (r1, i1) (r2, i2) = r1 +. r2, i1 +. i2
    end
  #+end_src

  #+RESULTS:
  #+begin_example
  Lines 1-5, characters 30-3:
  1 | ..............................struct
  2 |   type t = float * float
  3 |   let zero = 0, 0
  4 |   let add (r1, i1) (r2, i2) = r1 +. r2, i1 +. i2
  5 | end..
  Error: Signature mismatch:
         ...
         Values do not match:
           val zero : int * int
         is not included in
           val zero : t
  #+end_example

The ~ComplexSig~ type needs ~zero~ to have type ~float * float~. Since
the ~zero~ in this module has type ~int * int~, it doesn't typecheck
as being an instance of ~ComplexSig~.

**** TODO Big list queue [★★]

Use the following code to create ~ListQueue~ of exponentially increasing length: 10, 100, 1000, etc. How big of a queue can you create before there is a noticeable delay? How big until there’s a delay of at least 10 seconds? (Note: you can abort utop computations with Ctrl-C.)

Need the ~Queue~ signatur and the ~ListQueue~ type from section
5.6. Copied here with comments removed, since they were interfering
with the emacs / tuareg process in some way.

#+begin_src ocaml
  module type Queue = sig
    type 'a t
    exception Empty
    val empty : 'a t
    val is_empty : 'a t -> bool
    val enqueue : 'a -> 'a t -> 'a t
    val front : 'a t -> 'a
    val dequeue : 'a t -> 'a t
    val size : 'a t -> int
    val to_list : 'a t -> 'a list
  end
#+end_src

#+RESULTS:
#+begin_example
module type Queue =
  sig
    type 'a t
    exception Empty
    val empty : 'a t
    val is_empty : 'a t -> bool
    val enqueue : 'a -> 'a t -> 'a t
    val front : 'a t -> 'a
    val dequeue : 'a t -> 'a t
    val size : 'a t -> int
    val to_list : 'a t -> 'a list
  end
#+end_example

#+begin_src ocaml
module ListQueue : Queue = struct
  type 'a t = 'a list
  exception Empty
  let empty = []
  let is_empty = function [] -> true | _ -> false
  let enqueue x q = q @ [x]
  let front = function [] -> raise Empty | x :: _ -> x
  let dequeue = function [] -> raise Empty | _ :: q -> q
  let size = List.length
  let to_list = Fun.id
end
#+end_src

#+RESULTS:
: module ListQueue : Queue

#+begin_src ocaml :results verbatim
    (** Creates a ListQueue filled with [n] elements. *)
    let fill_listqueue n =
      let rec loop n q =
        if n = 0 then q
        else loop (n - 1) (ListQueue.enqueue n q) in
      loop n ListQueue.empty;;

    let timing f x =
      let t1 = Sys.time() in
      let result = f x in
      let t2 = Sys.time() in
      (result, t2 -. t1);;

    timing fill_listqueue 50000;;
#+end_src

#+RESULTS:
: - : int ListQueue.t * float = (<abstr>, 37.58237)

~10000~ took about 1 second, ~50000~ took about 30.

**** TODO Big batched queue [★★]
**** TODO Queue efficiency [★★★]
**** TODO Binary search tree map [★★★★]
**** DONE Fration [★★★]

Write a module that implements the Fraction module type below:

#+begin_src ocaml
module type Fraction = sig
  type t
  val make : int -> int -> t
  val numerator : t -> int
  val denominator : t -> int
  val to_string : t -> string
  val to_float : t -> float
  val add : t -> t -> t
  val mul : t -> t -> t
end
#+end_src

#+RESULTS:
#+begin_example
module type Fraction =
  sig
    type t
    val make : int -> int -> t
    val numerator : t -> int
    val denominator : t -> int
    val to_string : t -> string
    val to_float : t -> float
    val add : t -> t -> t
    val mul : t -> t -> t
  end
#+end_example

#+begin_src ocaml
  module Frac : Fraction = struct
    type t = int * int
    let make a b = (a, b)
    let numerator (a,b) = a
    let denominator (a,b) = b
    let to_string (a,b) = (string_of_int a)
                          ^ "/"
                          ^ (string_of_int b)
    let to_float (a,b) = (float_of_int a)
                         /. (float_of_int b)
    let add (a,b) (c,d) = (a*d + b*c, b*d)
    let mul (a,b) (c,d) = (a*c, b*d)
  end
#+end_src

#+RESULTS:
: module Frac : Fraction

#+begin_src ocaml
  let q = Frac.make 1 2;;
  let r = Frac.make 2 7;;
  let s = Frac.add q r in
    Frac.to_string s
#+end_src

#+RESULTS:
: 11/14

Didn't really think about how to handle / avoid the case where the
denominator is zero.

**** TODO Fraction reduced [★★★]

Modify your implementation of ~Fraction~ to ensure these invariants
hold of every value ~v~ of type ~t~ that is returned from ~make~, ~add~, and ~mul~:

+ ~v~ is in reduced form
+ the denominator of ~v~ is positive

For the first invariant, you might find this implementation of
Euclid’s algorithm to be helpful:

#+begin_src ocaml
  (** [gcd x y] is the greatest common divisor of [x] and [y].
      Requires: [x] and [y] are positive. *)
  let rec gcd x y =
    if x = 0 then y
    else if (x < y) then gcd (y - x) x
    else gcd y (x - y)
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml
  module Frac : Fraction = struct
    type t = int * int

    let make a b = let d = gcd a b in
                   (a/d, b/d)

    let numerator (a,b) = a

    let denominator (a,b) = b

    let to_string (a,b) = (string_of_int a)
                          ^ "/"
                          ^ (string_of_int b)

    let to_float (a,b) = (float_of_int a)
                         /. (float_of_int b)

    let add (a,b) (c,d) = let d = gcd (a*d + b*c) (b*d) in
                          (a*d + b*c, b*d)

    let mul (a,b) (c,d) = let d = gcd (a*c) (b*d) in
                          (a*c, b*d)
  end;;

  Frac.make 31991 101 |> Frac.to_string;;
  Frac.make 72 324 |> Frac.to_string;;

  let q = Frac.make 72 324 in
    let r = Frac.make 31991 101 in
    Frac.mul q r |> Frac.to_string
#+end_src

#+RESULTS:
: 63982/9

**** TODO Make char map [★]
**** TODO Char ordere [★]
**** TODO Use char map [★★]
**** TODO Bindings [★★]
**** TODO Date order [★★]
**** TODO Calendar [★★]
**** TODO Print calendar [★★]
**** TODO Is for [★★★]
**** TODO First after [★★★]
**** TODO Sets [★★★]
**** TODO ToString [★★]
**** TODO Print [★★]
**** TODO Print int [★★]
**** TODO Print string [★★]
**** TODO Print reuse [★]
**** TODO Print string reuse revisited [★★]
**** TODO Implementation without interface [★]
**** TODO Implementation with interface [★]
**** TODO Implementation with abstracted interface [★]
**** TODO Preinter for date [★★★]
**** TODO Refactor arith [★★★★]
*** TODO 6.11 Correctness - Exercises

*** 7.5 Mutability - Exercises
**** DONE mutable fields [★]

Define an OCaml record type to represent student names and GPAs. It
should be possible to mutate the value of a student’s GPA. Write an
expression defining a student with name ~"Alice"~ and GPA ~3.7~. Then
write an expression to mutate Alice’s GPA to ~4.0~

#+begin_src ocaml
  (* defining a record type with a mutable gpa field: *)
  type student = {name : string; mutable gpa: float};;

  (* create the specified instance *)
  let student_rec = {name = "Alice"; gpa = 3.7};;

  (* change the gpa as specified *)
  student_rec.gpa <- 4.0;;

  (* inspect to confirm *)
  student_rec
#+end_src

#+RESULTS:
: {name = "Alice"; gpa = 4.}

**** DONE refs [★]

Give OCaml expressions that have the following types. Use utop to
check your answers.

+ ~bool ref~

#+begin_src ocaml
  let br = ref true;;
#+end_src

#+RESULTS:
: {contents = true}

+ ~int list ref~

#+begin_src ocaml :results verbatim
  let ilr = ref [1;2;3]
#+end_src

#+RESULTS:
: val ilr : int list ref = {contents = [1; 2; 3]}

+ ~int ref list~

#+begin_src ocaml :results verbatim
  List.map (fun i -> ref i) [1;2]
#+end_src

#+RESULTS:
: - : int ref list = [{contents = 1}; {contents = 2}]

**** DONE inc fun [★]

Define a reference to a function as follows:

#+begin_src ocaml
  let inc = ref (fun x -> x + 1)
#+end_src

#+RESULTS:
: {contents = <fun>}

Write code that uses ~inc~ to produce the value ~3110~.

(This is disgusting)
#+begin_src ocaml
    let p = ref 0 in
    let q = ref 0 in
    let r = ref 0 in
    while ((!p) < 2)
    do (p := !p + 1)
    done;
    while ((!q) < 5)
    do (q := !q + 1)
    done;
    while ((!r) < 311)
    do (r := !r + 1)
    done;
    (!p) * (!q) * (!r);
#+end_src

#+RESULTS:
: 3110

**** DONE addition assignment [★★]

The ~C~ language and many languages derived from it, such as Java, has
an addition assignment operator written ~a += b~ and meaning ~a = a +
b~. Implement such an operator in OCaml; its type should be ~int ref
-> int -> unit~.

(uncomfortably close to line noise here, this function is like 60% punctuation)

#+begin_src ocaml
  let ( +:= ) x y = x := !x + y;;

  let x = ref 0;;

  x +:= 12;;
  x +:= 28;;
  x +:= -3;;

  !x;;
#+end_src

#+RESULTS:
: 37

**** DONE physical equality [★★]

Define ~x~, ~y~, and ~z~ as follows:

#+begin_src ocaml
  let x = ref 0
  let y = x
  let z = ref 0
#+end_src

#+RESULTS:
: {contents = 0}

Predict the value of the following series of expressions:

- ~x == y;;~
- ~x == z;;~
- ~x = y;;~
- ~x = z;;~
- ~x := 1;;~
- ~x = y;;~
- ~x = z;;~

+ ~# x == y;;~

~y~ is another name for ~x~. They should be equal.

#+begin_src ocaml
  x == y
#+end_src

#+RESULTS:
: true

+ ~# x == z;;~

~x~ and ~z~ are two different references. Different boxes with the
same content are not the same box. They should not be equal

#+begin_src ocaml
  x == z
#+end_src

#+RESULTS:
: false

+ ~# x = y;;~

My guess is that structural equality (same thing in memory) is
stronger than mathematical equality (evaluate to the same value), so
I'm guessing this is true:

#+begin_src ocaml
  x = y
#+end_src

#+RESULTS:
: true

+ ~# x = z;;~

both ~x~ and ~z~ are the same "value" (a reference containing a zero),
so I expect them to be "equal" despite not being the same reference.

#+begin_src ocaml
  x = z
#+end_src

#+RESULTS:
: true

+ ~# x := 1;;~

Switching the contents of reference ~x~ from ~0~ to ~1~.

#+begin_src ocaml
  x := 1
#+end_src

#+RESULTS:
: ()

+ ~# x = y;;~

~y~ is just a different name for the exact same location in
memory. When we changed ~x~, we also changed ~y~. They are still
(structurally) equal so they should still be mathematically equal

#+begin_src ocaml
  x = y
#+end_src

#+RESULTS:
: true

+ ~# x = z;;~

These two used to be references containing the same value. But now ~x~
contains ~1~ while ~z~ still contains ~0~. So they should no longer be
equal.

#+begin_src ocaml
  x = z
#+end_src

#+RESULTS:
: false

**** DONE norm [★★]

The Euclidean norm of an $n$-dimensional vector $x = (x_1, \ldots,
x_n)$ is written $|x|$ and is defined to be $$\sqrt{x_1^2 + \cdots +
x_n^2}.$$ Write a function ~norm: vector -> float~ that computes the
Euclidean norm of a vector, where ~vector~ is defined as follows:

#+begin_src ocaml
  (* AF: the float array [| x1; ...; xn |] represents the
   ,*     vector (x1, ..., xn)
   ,* RI: the array is non-empty *)
  type vector = float array
#+end_src

#+begin_src ocaml
  let norm vect = 
    vect
    |> Array.map (function x -> x *. x)
    |> Array.fold_left (+.) 0.
    |> Float.sqrt;;

  norm [|5.0; 12.0|];;

  norm [|0.0;12.0;34.0;56.0;78.0|]
#+end_src

#+RESULTS:
: 102.56705123966468

**** DONE normalize [★★]

Every vector $x$ can be normalized by dividing each component by
$|x|$. This yields a vector with norm $1$.

Write a function ~normalize : vector -> unit~ that normalizes a vector
“in place” by mutating the input array. Here’s a sample usage:

#+begin_src ocaml
  # let a = [|1.; 1.|];;
  val a : float array = [|1.; 1.|]

  # normalize a;;
  - : unit = ()

  # a;;
  - : float array = [|0.7071...; 0.7071...|]
#+end_src

This works and doesn't use a loop, but it's not clear to me that it's
the "right" way to do this. Seems like an abuse of ~mapi~, and my
suspicion is there's something better suited to this purpose.

#+begin_src ocaml :results verbatim
  let normalize vect =
    let n = norm vect in
    let replace_at i e = vect.(i) <- e /. n in
    ignore (vect |> Array.mapi replace_at);;

  let v = [|3.0; 4.0|];;
  norm v;;
  normalize v;;
  v;;
  norm v;;
#+end_src

#+RESULTS:
: - : float = 1.

**** DONE norm loop [★★]

Modify your implementation of ~norm~ to use a loop.

#+begin_src ocaml
  let norm vect =
    let len = Array.length vect in
    let sum_of_squares = ref 0.0 in
    let i = ref 0 in
    while (!i < len)
    do (sum_of_squares := !sum_of_squares +. (vect.(!i) *. vect.(!i));
        i := !i + 1)
    done;
    Float.sqrt(!sum_of_squares);;

  norm [|5.0; 12.0|]
#+end_src

#+RESULTS:
: 13

**** DONE normalize loop [★★]

Modify your implementation of ~normalize~ to use a loop.

#+begin_src ocaml :results verbatim
  let normalize vect =
    let n = Array.length vect in
    let n = norm vect in
    let i = ref 0 in
    while !i < len
    do (vect.(!i) <- vect.(!i) /. n;
        i := !i + 1)
    done;;

  let v = [| 3.0; 4.0 |];;

  norm v;;
  normalize v;;
  v;;
  norm v;;
#+end_src

**** DONE init matrix [★★★]

The ~Array~ module contains two functions for creating an array:
~make~ and ~init~. ~make~ creates an array and fills it with a default
value, while ~init~ creates an array and uses a provided function to
fill it in. The library also contains a function ~make_matrix~ for
creating a two-dimensional array, but it does not contain an analogous
~init_matrix~ to create a matrix using a function for initialization.

Write a function ~init_matrix : int -> int -> (int -> int -> 'a) -> 'a
array array~ such that ~~init_matrix n o f~ creates and returns an ~n~
by ~o~ matrix ~m~ with ~m.(i).(j) = f i j~ for all ~i~ and ~j~ in
bounds.

See the documentation for ~make_matrix~ for more information on the
representation of matrices as arrays.

(I refuse to use "n x o" matrix. All matrices are m x n. C'mon now.)

#+begin_src ocaml
  let init_matrix m n f = 
    Array.init m (fun i -> Array.init n (fun j -> f i j));;
#+end_src

#+begin_src ocaml
  init_matrix 4 4 (fun i j -> i + 2*j)
#+end_src

#+RESULTS:
| 0 | 2 | 4 | 6 |
| 1 | 3 | 5 | 7 |
| 2 | 4 | 6 | 8 |
| 3 | 5 | 7 | 9 |

**** TODO doubly linked list [★★★★]
* Learning OCaml - problems
** 99 OCaml Problems

Working through [[https://ocaml.org/problems#1][this list]] of problems

*** Checklist
| Nummber | Description            | Status |
|---------+------------------------+--------|
|         | Miscellaneous          |        |
|---------+------------------------+--------|
|       1 | tail of a list         | done   |
|       2 | last two elements      | done   |
|       3 | nth_element            | done   |
|       4 | list length            | done   |
|       5 | reverse                | done   |
|       6 | palindrome             | done   |
|       7 | flatten                | done   |
|       8 | delete duplicates      | done   |
|       9 | pack                   | done   |
|      10 | run-length             | done   |
|      11 | run-length mod         | done   |
|      12 | run-length decode      | done   |
|      13 | run-length direct      | done   |
|      14 | duplicate elts         | done   |
|      15 | replicate elts         | done   |
|      16 | drop every nth         | done   |
|      17 | split list             | done   |
|      18 | list slice             | done   |
|      19 | rotate n left          | done   |
|      20 | remove kth             | done   |
|      21 | insert                 | done   |
|      22 | range                  | done   |
|      23 | extract random         | done   |
|      24 | lotto                  | done   |
|      25 | random permutation     | done   |
|      26 | k choose n             | done   |
|      27 | partitions             |        |
|      28 | sort by length         | done   |
|---------+------------------------+--------|
|         | Arithmetic             |        |
|---------+------------------------+--------|
|      29 | prime                  | done*  |
|      30 | gcd                    | done   |
|      31 | coprime                | done   |
|      32 | euler phi              | done   |
|      33 | prime factors          |        |
|      34 | prime factors 2        |        |
|      35 | euler phi 2            |        |
|      36 | compare euler phis     |        |
|      37 | prime list             | done   |
|      38 | goldbach               |        |
|      39 | goldbach list          |        |
|---------+------------------------+--------|
|         | Logic and Codes        |        |
|---------+------------------------+--------|
|      40 | truth tables 1         |        |
|      41 | truth tables 2         |        |
|      42 | gray code              | done   |
|      43 | huffman code           |        |
|---------+------------------------+--------|
|         | Trees                  |        |
|---------+------------------------+--------|
|      44 | balanced binary tree   | done   |
|      45 | symmetric binary tree  | done   |
|      46 | binary search tree     |        |
|      47 | generate and test      |        |
|      48 | height balanced tree   |        |
|      49 | height balanced tree 2 |        |
|      50 | collect leaves in list | done   |
|      51 | count leaves           | done   |
|      52 | collect nodes at level | done   |
|      53 | collect internal nodes | done   |
|      54 | complete binary tree   |        |
|      55 | layout binary tree     |        |
|      56 | layout binary tree 2   |        |
|      57 | layout binary tree 3   |        |
|      58 | string rep tree        |        |
|      59 | seqeuences of trees    |        |
|      60 | dotstring of tree      |        |
|---------+------------------------+--------|
|         | Multiway trees         |        |
|---------+------------------------+--------|
|      61 | nodes of multiway tree |        |
|      62 | tree from node string  |        |
|      63 | internal path length   |        |
|      64 | bottom up order        |        |
|      65 | lisp-like tree rep     |        |
|---------+------------------------+--------|
|         | Graphs                 |        |
|---------+------------------------+--------|
|      66 | conversions            |        |
|      67 | paths                  |        |
|      68 | cycles                 |        |
|      69 | all spanning           |        |
|      70 | min spanning           |        |
|      71 | graph isomorphism      |        |
|      72 | node degree + color    |        |
|      73 | depth first traverse   |        |
|      74 | connected components   |        |
|      75 | bipartite              |        |
|      76 | k regular n node       |        |
|---------+------------------------+--------|
|         | Miscellaneous          |        |
|---------+------------------------+--------|
|      77 | eight queens           |        |
|      78 | knights tour           |        |
|      79 | von koch               |        |
|      80 | arithmetic puzzle      |        |
|      81 | number words           |        |
|      82 | syntax checker         |        |
|      83 | sudoku                 |        |
|      84 | nonograms              |        |
|      85 | crossword              |        |
|---------+------------------------+--------|

*** Lists
**** DONE 1 Tail of a list
Write a function ~last : 'a list -> 'a option~ that returns the last
element of a list.

#+begin_src ocaml

    let rec last lst = match lst with
      | [] -> None
      | x :: [] -> Some x
      | x :: xs -> last xs;;

    last [1;2;3];;
    last [1];;
    last []
#+end_src

#+RESULTS:
: None
**** DONE 2 Last two elements of a list

Find the last but one (last and penultimate) elements of a list.

#+begin_src ocaml

    let rec last_two lst = match lst with
      | [] -> None
      | x :: [] -> None
      | x :: y :: [] -> Some (x, y)
      | x :: xs -> last_two xs;;

    last_two [1;3;2;4;3;2;3];;
    last_two [1;3];;
    last_two [1];;
    last_two []
#+end_src

#+RESULTS:
: None

**** DONE 3 Nth element of a list

Find the K^{th} element of a list.

This one requires the parentehses around the inner ~match~
expressions. Otherwise, it thinks ~m~ is of type ~'a list~.

#+begin_src ocaml
  let rec at n lst = match n with
    | 0 -> None
    | 1 -> (match lst with
            | [] -> None
            | x :: xs -> Some x)
    | m -> (match lst with
            | [] -> None
            | x :: xs -> at (m - 1) xs);;

  at 3 [1;2;3;4;5]
#+end_src

#+RESULTS:
: Some 3

**** DONE 4 length of a list
Find the number of elements of a list

#+begin_src ocaml

    let length lst =
      let rec length_acc i lst = match lst with
        | [] -> i
        | x :: xs -> length_acc (i + 1) xs in
      length_acc 0 lst;;

    length [1;2;3;4;5];;
    length [];;
#+end_src

#+RESULTS:
: 0

**** DONE 5 Reverse a list

Reverse a list

#+begin_src ocaml

    let rec rev lst = match lst with
      | [] -> []
      | x :: xs -> (rev xs) @ (x::[]);;

    rev [1;2;5;4;3]
#+end_src

#+RESULTS:
| 3 | 4 | 5 | 2 | 1 |

**** DONE 6 Palindrome
Find out whether a list is a palindrom

#+begin_src ocaml

   let rec is_palindrome lst =
     let revlst = rev lst in
     let rec list_equals l1 l2 = match l1 with
       | [] -> (match l2 with
                | [] -> true
                | y :: ys -> false)
       | x :: xs -> (match l2 with
                     | [] -> false
                     | y :: ys -> (match y with
                                   | y when y = x -> list_equals xs ys
                                   | _ -> false)) in
   list_equals lst revlst;;

   [is_palindrome [1;2;2;1];
    is_palindrome [1];
    is_palindrome [];
    is_palindrome [1;2;3;4;5;4;3;2;1];
    is_palindrome [1;2;3;4;3];
    is_palindrome [1;2;3]]

#+end_src

#+RESULTS:
| true | true | true | true | false | false |

**** DONE 7 Flatten a list

Flatten a nested list structure

#+begin_src ocaml :results verbatim
    (* type definition for nested list *)
    type 'a node =
      | One of 'a 
      | Many of 'a node list;;

    let rec flatten nl = match nl with
      | [] -> []
      | (One x) :: xs -> x :: flatten xs
      | (Many xs) :: xss -> (flatten xs) @ (flatten xss);;

    flatten [One "a"; Many [One "b"; Many [One "c" ;One "d"]; One "e"]]
#+end_src

#+RESULTS:
: - : string list = ["a"; "b"; "c"; "d"; "e"]

**** DONE 8 Eliminate duplicates

Eliminate consecutive duplicates of list elements.

#+begin_src ocaml

    let rec compress l = match l with
      | [] -> []
      | x :: [] -> x :: []
      | x :: y :: xs when x = y -> compress (y :: xs)
      | x :: y :: xs when x <> y -> x :: compress (y :: xs);;

    compress [1;1;1;1;2;2;2;2;3;3;4;4;5;5;6;5;4]
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 |

**** DONE 9 Pack consecutive duplicates

Pack consecutive duplicates of list elements into sublists

#+begin_src ocaml

  let pack l =
    let rec pack_help h l = match h with
      | [] -> (match l with
               | [] -> []
               | x :: xs -> pack_help [x] xs)
      | y :: ys -> (match l with
                    | [] -> [h]
                    | x :: xs -> match x with
                                      | x when x = y -> pack_help (x :: h) xs 
                                      | _ -> h :: (pack_help [x] xs)) in
    pack_help [] l;;

  pack [1;1;1;2;2;3;3;3;3;3;4;5;6;4]
#+end_src

#+RESULTS:
| 1 | 1 | 1 |   |   |
| 2 | 2 |   |   |   |
| 3 | 3 | 3 | 3 | 3 |
| 4 |   |   |   |   |
| 5 |   |   |   |   |
| 6 |   |   |   |   |
| 4 |   |   |   |   |

**** DONE 10 Run length encoding

Run-length encoding of a list

#+begin_src ocaml :results verbatim

  let encode l =
    let rle x = (List.length x, List.hd x) in
    l |> pack |> List.map rle;;

  encode [1;1;1;1;2;3;4;4;4;4;4;4;4;4;3;3;2]
#+end_src

#+RESULTS:
: - : (int * int) list = [(4, 1); (1, 2); (1, 3); (8, 4); (2, 3); (1, 2)]

**** DONE 11 Modified Run-length encoding

Modify the result of the previous problem in such a way that if an
element has no duplicates it is simply copied into the result
list. Only elements with duplicates are transferred as (N E) lists.

Since OCaml lists are homogeneous, one needs to define a type to hold
both single elements and sub-lists.

#+begin_src ocaml
type 'a rle =
  | One of 'a
  | Many of int * 'a
#+end_src

#+RESULTS:
: type 'a rle = One of 'a | Many of int * 'a

#+begin_src ocaml :results verbatim
  let encode lst =
    let rle_of_packed l = match l with
      | x :: [] -> One x
      | x :: xs -> Many (List.length l, x) in
    lst |> pack |> List.map rle_of_packed;;

  encode [1;1;2;2;3;3;3;4;5;5;5;5;5];;
#+end_src

#+RESULTS:
: - : int rle list =
: [Many (2, 1); Many (2, 2); Many (3, 3); One 4; Many (5, 5)]

**** DONE 12 Decode a run-length encoded list

Given a run-length code list generated as specified in the previous
problem, construct its uncompressed version.

#+begin_src ocaml :results verbatim
    let decode lst =
      let rec unpack e = match e with
        | One x -> [x]
        | Many (n,x) -> (match n with
                          | 2 -> x :: x :: []
                          | _ -> x :: unpack (Many (n-1,x))) in
      lst |> List.map unpack |> List.fold_left (@) [];;

  decode [Many (2, 1); Many (2, 2); Many (3, 3); One 4; Many (5, 5)]
#+end_src

#+RESULTS:
: - : int list = [1; 1; 2; 2; 3; 3; 3; 4; 5; 5; 5; 5; 5]

can this be done without the fold?

**** DONE 13 Run-length encoding of a list (direct solution)

Implement the so-called run-length encoding data compression method
directly. I.e. don't explicitly create the sublists containing the
duplicates, as in problem "Pack consecutive duplicates of list
elements into sublists", but only count them. As in problem "Modified
run-length encoding", simplify the result list by replacing the
singleton lists (1 X) by X.

#+begin_src ocaml :results verbatim
    let encode lst =
      let rec encode_acc ct e lst = match lst with
        | [] -> (match ct with
                | 1 -> [One e]
                | n -> [Many (n,e)])
        | x :: [] when x = e -> [Many (ct + 1, e)]
        | x :: [] -> (match ct with
                     | 1 -> [One e; One x]
                     | n -> [Many (ct, e); One x])
        | x :: xs when x = e -> encode_acc (ct + 1) e xs 
        | x :: xs -> (match ct with
                     | 1 -> (One e) :: encode_acc 1 x xs
                     | n -> (Many (n,e)) :: encode_acc 1 x xs) in
      match lst with
      | [] -> []
      | x :: xs -> encode_acc 1 x xs;;

    encode [1;1;1;1;2;2;3;3;3;3;4;5;6;5;4;4;4;4;5;5;5;5;5;5;5;5;5;0];;
#+end_src

#+RESULTS:
: - : int rle list =
: [Many (4, 1); Many (2, 2); Many (4, 3); One 4; One 5; One 6; One 5;
:  Many (4, 4); Many (9, 5); One 0]

**** DONE 14 Duplicate the elements of a list

Duplicate the elements of a list

#+begin_src ocaml :results verbatim
    let rec duplicate lst = match lst with
      | [] -> []
      | x :: xs -> x :: x :: duplicate xs;;

    duplicate ["a";"b";"c";"c";"d"]
#+end_src

#+RESULTS:
: - : string list = ["a"; "a"; "b"; "b"; "c"; "c"; "c"; "c"; "d"; "d"]

**** DONE 15 Replicate the elements of a list a given number of times

Replicate the elements of a list a given number of times

#+begin_src ocaml :results verbatim
    let rec replicate lst n =
      let rec repeated n e = match n with
        | 0 -> []
        | n -> e :: repeated (n-1) e in
      lst |> List.map (repeated n) |> List.fold_left (@) [];;

    replicate [1;2;3;3;4] 4
#+end_src

#+RESULTS:
: - : int list = [1; 1; 1; 1; 2; 2; 2; 2; 3; 3; 3; 3; 3; 3; 3; 3; 4; 4; 4; 4]

**** DONE 16 Drop every N'th element from a list

Drop every N'th element from a list

#+begin_src ocaml :results verbatim
  let drop lst n =
    let rec drop_help lst n m = match m with
      | 1 -> (match lst with
              | [] -> []
              | x :: xs -> drop_help xs n n)
      | m -> (match lst with
              | [] -> []
              | x :: xs -> x :: (drop_help xs n (m-1))) in
    drop_help lst n n;;

  drop [1;2;3;4;5;6;7;8;9;10] 3
#+end_src

#+RESULTS:
: - : int list = [1; 2; 4; 5; 7; 8; 10]

**** DONE 17 Split a list into two parts; the length of the first part is given

Split a list into two parts; the length of the first part is given

If the length of the first part is longer than the entire list, then
the first part is the list and the second part is empty.

#+begin_src ocaml :results verbatim
    let split lst n =
      let rec split_help lst partial n = match n with
        | 0 -> [List.rev partial; lst]
        | n -> (match lst with
                | [] -> [List.rev partial;lst]
                | x :: xs -> split_help xs (x :: partial) (n-1)) in
      split_help lst [] n;;

    split [1;2;3;4;5;6;7] 4;;

#+end_src

#+RESULTS:
: - : int list list = [[1; 2; 3; 4]; [5; 6; 7]]

**** DONE 18 Extract a slice from a list

Given two indices, ~i~ and ~k~, the slice is the list containing the
elements between the ~ith~ and ~kth~ element of the original list
(both limits included). Start counting the elements with ~0~ (this is
the way the List module numbers elements).

#+begin_src ocaml :results verbatim
  let rec slice lst i j = match i with
    | 0 -> (match j with
           | 0 -> (match lst with
                  | [] -> []
                  | x :: xs -> [x])
           | j when j > 0 -> (match lst with
                             | [] -> []
                             | x :: xs -> x :: (slice xs 0 (j-1)))
           | j -> [])
    | i -> (match lst with
            | [] -> []
            | x :: xs -> slice xs (i-1) (j-1));;

  slice [1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17] 5 7
#+end_src

#+RESULTS:
: - : int list = [6; 7; 8]

**** DONE 19 Rotate a list N places to the left

Rotate a list N places to the left

#+begin_src ocaml :results verbatim
    let rotate lst n =
      let l = List.length lst in
      let m = if (n mod l >= 0) then (n mod l) else ((n mod l) + l) in
      let rec rotate_help lst part n = match n with
        | 0 -> lst @ part
        | n -> (match lst with
                | [] -> part
                | x :: xs -> rotate_help xs (part @ [x]) (n-1)) in
      rotate_help lst [] m;;

    rotate [1;2;3;4;5;6;7] (-8);;
    rotate [1;2;3;4;5;6;7] (1000);;
    rotate [1] (100000);;
    rotate [1;2;3;4;5;6;7] (-12367)

#+end_src

#+RESULTS:
: - : int list = [3; 4; 5; 6; 7; 1; 2]

**** DONE 20 Remove the K'th element from a list
Remove the K'th element from a list

The first element of the list is numbered 0, the second 1,...

#+begin_src ocaml :results verbatim
    let remove_at k lst =
      let rec remove_at_help k lst partial = match k with
        | 0 -> (match lst with
                | [] -> partial
                | x :: xs -> partial @ xs)
        | k -> (match lst with
               | [] -> partial
               | x :: xs -> remove_at_help (k-1) xs (partial @ [x]))  in
      remove_at_help k lst [];;

    remove_at 3 [1;2;3;4;5;6;7];;
#+end_src

#+RESULTS:
: - : int list = [1; 2; 3; 5; 6; 7]

**** DONE 21 Insert element into a list at a given position 

Start counting list elements with 0. If the position is larger or
equal to the length of the list, insert the element at the end. (The
behavior is unspecified if the position is negative.)

#+begin_src ocaml :results verbatim
    let rec insert_at e i lst =
      match i with
      | j when j <= 0 -> e :: lst
      | i -> (match lst with
             | [] -> [e]
             | x :: xs -> x :: (insert_at e (i-1) xs));;

    insert_at 2 4 [1;1;1;1;1;1;1;1;1]
#+end_src

#+RESULTS:
: - : int list = [1; 1; 1; 1; 2; 1; 1; 1; 1; 1]

(not tail recursive. can be re-written to be so, but I can only see a
way that might overuse the ~@~ operator)
**** DONE 22 Create a list containing all integers within a given range

If first argument is greater than second, produce a list in decreasing
order

#+begin_src ocaml :results verbatim
    let rec range i j =
      let k = j - i in
      match k with
      | k when k < 0 -> i :: (range (i-1) j)
      | k when k = 0 -> [i]
      | k -> i :: range (i+1) j;;

    range (-10) (-2);;
    range 1 42;;
    range 4 4;;
    range 10 0
#+end_src

#+RESULTS:
: - : int list = [10; 9; 8; 7; 6; 5; 4; 3; 2; 1; 0]

**** DONE 23 Extract a given number of randomly selected elements from a list

The selected items shall be returned in a list. We use the Random
module but do not initialize it with Random.self_init for
reproducibility.

(I'm assuming this means the elements should be distinct? as in, a
random subset of the specified size?)

If the list has length ~n~ and you're picking ~k~ elements, then there are ~n~
choose ~k~ subsets. And ~n-1~ choose ~k-1~ of them will contain the
first element. So with probability \(\frac{k}{n}\), pick the first
element, and recursively choose ~k-1~ elements in the tail of the
list. But with probability \(1- \frac{k}{n}\), don't pick the first
element, and instead pick ~k~ elements from the tail of the list.

#+begin_src ocaml :results verbatim
  let rec rand_select lst k =
    let n = List.length lst in
    match k with
    | k when k > n -> []
    | k when k = n -> lst
    | k -> let i = Random.int n in
           match lst with
           | [] -> []
           | x :: xs -> if i + 1 <= k
                        then (x :: rand_select xs (k-1))
                        else (rand_select xs k);;

  rand_select [1;2;3;4;5;6;7] 3
#+end_src

#+RESULTS:
: - : int list = [2; 4; 5]

seems pretty random. Should probably do actual statistics to be sure,
but I trust my math.

**** DONE 24 Lotto: Draw N different random numbers from the set 1..M

Draw N different random numbers from the set 1 ... M

The selected numbers shall be returned in a list.

#+begin_src ocaml
    let lotto_select n m = rand_select (range 1 m) n;;

    lotto_select 5 50
#+end_src

#+RESULTS:
| 11 | 14 | 29 | 39 | 49 |

**** DONE 25 Generate a random permutation of the elements of a list

Generate a random permutation of the elements of a list

(this can probably be done more efficiently. Using ~remove_at~ from
earlier might be bad)

#+begin_src ocaml :results verbatim
  let permutation lst = match lst with
    | [] -> []
    | _ -> let n = List.length lst in
           let i = Random.int n in
           let h = List.nth lst i in
           h :: permutation (remove_at i lst);;


  permutation (range 1 100)
#+end_src

#+RESULTS:
: - : int list =
: [51; 96; 40; 69; 10; 99; 70; 19; 77; 100; 16; 57; 84; 38; 63; 11; 62; 4; 87;
:  65; 94; 29; 7; 53; 74; 50; 12; 9; 46; 73; 48; 33; 20; 54; 88; 3; 14; 67; 44;
:  89; 8; 1; 35; 95; 6; 78; 42; 2; 32; 13; 71; 68; 25; 90; 52; 97; 91; 60; 31;
:  76; 82; 80; 36; 28; 34; 30; 56; 83; 37; 23; 41; 24; 5; 15; 22; 66; 55; 17;
:  26; 61; 75; 58; 86; 79; 59; 43; 45; 85; 93; 98; 72; 92; 39; 21; 18]

**** DONE 26 Generate the combinations of K distinct objects chosen from the N elements of a list

Generate the combinations of ~K~ distinct objects chosen from the ~N~ elements of a list.

In how many ways can a committee of ~3~ be chosen from a group of ~12~
people? We all know that there are ~12~ choose ~3~ = ~220~
possibilities. For pure mathematicians, this result may be great. But
we want to really generate all the possibilities in a list.

#+begin_src ocaml :results verbatim
      let rec extract k lst = match k with
        | k when k < 0 -> []
        | 0 -> [[]]
        | k -> (let n = List.length lst in
                match n with
                | n when n < k -> []
                | n when n = k -> [lst]
                | n -> (match lst with
                        | [] -> []
                        | x :: xs ->
                           (List.map (fun s -> x :: s) (extract (k-1) xs))
                           @ (extract k xs)));;

    extract 0 [1;2;3;4;5;6];;
    extract 1 [1;2;3;4;5;6];;
    extract 2 [1;2;3;4;5;6];;
    extract 6 [1;2;3;4;5;6];;
#+end_src

#+RESULTS:
: - : int list list = [[1; 2; 3; 4; 5; 6]]

**** TODO 27 - Group the elements of a list into disjoint subsets 

Group the elements of a set into disjoint subsets

+ In how many ways can a group of 9 people work in 3 disjoint
  subgroups of 2, 3 and 4 persons? Write a function that generates all
  the possibilities and returns them in a list.

+ Generalize the above function in a way that we can specify a list of group sizes and the function will return a list of groups.

**** DONE 28 Sorting a list of lists according to length of sublists

Sorting a list of lists according to length of sublists.

+ We suppose that a list contains elements that are lists
  themselves. The objective is to sort the elements of this list
  according to their length. E.g. short lists first, longer lists
  later, or vice versa.
  
+ Again, we suppose that a list contains elements that are lists
  themselves. But this time the objective is to sort the elements of
  this list according to their length frequency; i.e., in the default,
  where sorting is done ascendingly, lists with rare lengths are
  placed first, others with a more frequent length come later.

#+begin_src ocaml :results verbatim
    let length_sort lst =
      let ( <<< ) l1 l2 = List.length l1 < List.length l2 in
      let rec qs lst comparison = match lst with
        | [] -> []
        | x :: xs -> (let in_left l = l <<< x in
                     let (left, right) = List.partition in_left xs in
                     (qs left (<<<)) @ [x] @ (qs right (<<<))) in
      qs lst (<<<);;

    length_sort [[1;2;3];[4];[5;6];[7;7];[]]
#+end_src

#+RESULTS:
: - : int list list = [[]; [4]; [5; 6]; [7; 7]; [1; 2; 3]]
*** Arithmetic
**** TODO 29 Primality test

Determine whether a given integer is prime

Ordinary naive seive:

#+begin_src ocaml :results verbatim
    let is_prime_seive n =
      if n < 2
      then false
      else (let bound = n
                        |> float_of_int
                        |> Float.sqrt
                        |> Float.floor
                        |> int_of_float in
            let rec range a b =
              let s = b - a in
              match s with
              | s when s < 0 -> []
              | 0 -> [a]
              | s -> a :: range (a+1) b in
            let candidates = range 2 bound in
            (* seive lst m = true if a number in lst,
             is a divisor of m, false otherwise. *)
            let rec seive lst m = match lst with
              | [] -> (false)
              | p :: qs -> (if m mod p = 0
                            then true
                            else seive qs m) in
            not (seive candidates n));;

    let rec range a b =
      let s = b - a in
      match s with
      | s when s < 0 -> []
      | 1 -> [a]
      | s -> a :: range (a+1) b;;

    List.filter is_prime_seive (range 1 100000)
#+end_src

#+RESULTS:
#+begin_example
- : int list =
[2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71;
 73; 79; 83; 89; 97; 101; 103; 107; 109; 113; 127; 131; 137; 139; 149; 151;
 157; 163; 167; 173; 179; 181; 191; 193; 197; 199; 211; 223; 227; 229; 233;
 239; 241; 251; 257; 263; 269; 271; 277; 281; 283; 293; 307; 311; 313; 317;
 331; 337; 347; 349; 353; 359; 367; 373; 379; 383; 389; 397; 401; 409; 419;
 421; 431; 433; 439; 443; 449; 457; 461; 463; 467; 479; 487; 491; 499; 503;
 509; 521; 523; 541; 547; 557; 563; 569; 571; 577; 587; 593; 599; 601; 607;
 613; 617; 619; 631; 641; 643; 647; 653; 659; 661; 673; 677; 683; 691; 701;
 709; 719; 727; 733; 739; 743; 751; 757; 761; 769; 773; 787; 797; 809; 811;
 821; 823; 827; 829; 839; 853; 857; 859; 863; 877; 881; 883; 887; 907; 911;
 919; 929; 937; 941; 947; 953; 967; 971; 977; 983; 991; 997; 1009; 1013;
 1019; 1021; 1031; 1033; 1039; 1049; 1051; 1061; 1063; 1069; 1087; 1091;
 1093; 1097; 1103; 1109; 1117; 1123; 1129; 1151; 1153; 1163; 1171; 1181;
 1187; 1193; 1201; 1213; 1217; 1223; 1229; 1231; 1237; 1249; 1259; 1277;
 1279; 1283; 1289; 1291; 1297; 1301; 1303; 1307; 1319; 1321; 1327; 1361;
 1367; 1373; 1381; 1399; 1409; 1423; 1427; 1429; 1433; 1439; 1447; 1451;
 1453; 1459; 1471; 1481; 1483; 1487; 1489; 1493; 1499; 1511; 1523; 1531;
 1543; 1549; 1553; 1559; 1567; 1571; 1579; 1583; 1597; 1601; 1607; 1609;
 1613; 1619; 1621; 1627; 1637; 1657; 1663; 1667; 1669; 1693; 1697; 1699;
 1709; 1721; 1723; 1733; 1741; 1747; 1753; 1759; 1777; 1783; 1787; 1789;
 1801; 1811; 1823; 1831; 1847; 1861; 1867; 1871; 1873; 1877; 1879; 1889;
 1901; 1907; 1913; 1931; 1933; 1949; 1951; 1973; 1979; ...]
#+end_example

Miller-Rabin:
#+begin_src ocaml :results verbatim
  let is_prime n = match n with
    | n when n < 2 -> false
    | 2 -> true
    | n when n mod 2 = 0 -> false
    | n -> (let witnesses = [2;3;5;7;11;13;17;19;23;29;31;37] in
            let rec twos_exponent m =
              match m with
              | m when m mod 2 = 1 -> 0
              | m -> 1 + twos_exponent (m / 2) in
            let rec power a b = match b with
              | 0 -> 1
              | b -> a * pow a (b-1) in
            let rec powermod a b n = match b with
              | 0 -> 1
              | b -> (a * powermod a (b-1) n) mod n in
            let fermat_test a d n =
              powermod a d n = 1 in
            let rec root_test a r s n = () in
            let s = twos_exponent (n-1) in
            let d = (n-1) / (pow 2 s) in
            (
            (* miller-rabin goes here*)
            )
           );;
  is_prime 1001
#+end_src

#+RESULTS:
: 3
: 125
: - : bool = true

**** DONE 30 - Determine the greatest common divisor of two positive integer numbers

Determine the greatest common divisor of two positive integer numbers.

Use Euclid's algorithm.

#+begin_src ocaml
  let rec gcd a b =
    if (a < b)
    then (gcd b a)
    else let q = a / b in
         let r = a - q*b in
         match r with
         | 0 -> b
         | r -> gcd b r;;

  gcd (324*17*11*13) (324*2*5*101);;
#+end_src

#+RESULTS:
: 324

**** DONE 31 - Determine whether two positive integer numbers are coprime

Determine whether two positive integer numbers are coprime.

Two numbers are coprime if their greatest common divisor equals 1.

(seems trivial)

#+begin_src ocaml
  let rec coprime a b = gcd a b = 1;;
#+end_src

#+RESULTS:
: <fun>

**** DONE 32 - Calculate Euler's totient function \(\phi(m)\)

Euler's so-called totient function φ(m) is defined as the number of
positive integers r (1 ≤ r < m) that are coprime to m. We let φ(1)
= 1.


Find out what the value of φ(m) is if m is a prime number. Euler's
totient function plays an important role in one of the most widely
used public key cryptography methods (RSA). In this exercise you
should use the most primitive method to calculate this function (there
are smarter ways that we shall discuss later).

(doing it the naive way:)

#+begin_src ocaml
  let phi m = match m with
    | 1 -> 1
    | m -> (let range a b =
              let s = b - a in
              match s with
              | s when s < 0 -> []
              | 0 -> [a]
              | s -> a :: range (a+1) b in
            let rec count_coprimes acc lst n =
              match lst with
              | [] -> acc
              | d :: ds -> if (gcd n d = 1)
                           then (count_coprimes (acc+1) ds n)
                           else (count_coprimes acc ds n) in
            count_coprimes 0 (range 1 m) m);;

  phi 12321
#+end_src

#+RESULTS:
: 7992

**** TODO 33 - Determine the prime factors of a given positive integer

BUGGY - check n = 25, it's failing there for some reason

Construct a flat list containing the prime factors in ascending order.

#+begin_src ocaml :results verbatim
  let rec factors n =
    if is_prime_seive n
    then [n]
    else
      let bound = n
                  |> float_of_int
                  |> Float.sqrt
                  |> Float.floor
                  |> int_of_float in
      let range a b =
        let s = b - a in
        match s with
        | s when s < 0 -> []
        | 0 -> [a]
        | s -> a :: range(a+1) b in
      let potential_divisors = range 2 bound
                               |> List.filter is_prime_seive in
      let rec smallest_prime_factor lst m = match lst with
        | [] -> 1 (* impossible branch since n is composite *)
        | d :: ds -> if m mod d = 0 then d else smallest_prime_factor ds m in
      let p = smallest_prime_factor potential_divisors n in
      p :: factors (n/p);;

  factors (324*72*17*11)
#+end_src

#+RESULTS:
: - : int list = [2; 2; 2; 2; 2; 3; 3; 3; 3; 3; 3; 11; 17]

**** DONE 34 - Determine the prime factors of a given positive integer (2)

Construct a list containing the prime factors and their
multiplicity. Hint: The problem is similar to problem 13

doing it the naive way for now:

#+begin_src ocaml :results verbatim
    let factors_with_multiplicity n =
      let rec compress count p lst = match lst with
        | [] -> [(p,count)]
        | x :: xs when x = p -> compress (count+1) p xs
        | x :: xs ->(p,count) :: compress 1 x xs in
      match factors n with
      | [] -> []
      | [p] -> [(p,1)]
      | p :: ps -> compress 1 p ps;;

    factors_with_multiplicity (324*72*17*11*37)
#+end_src

#+RESULTS:
: - : (int * int) list = [(2, 5); (3, 6); (11, 1); (17, 1); (37, 1)]

**** TODO 35 Calculate Euler's totient function (improved)

#+begin_src ocaml
      let eulerphi m =
        let facts = factors_with_multiplicity m in
        let rec exp a b = match b with
          | 0 -> 1
          | b -> a * (exp a (b-1)) in
        let rec phi_list_product lst = match lst with
          | [] -> 1
          | (p,e) :: tail -> (p-1) * (exp p (e-1)) * phi_list_product tail in
        phi_list_product facts;;

    (* check that it agrees w/ the previous *)
      factors 50
#+end_src

#+RESULTS:
: Stack overflow during evaluation (looping recursion?).

**** TODO 36 Compare the two methods of calculating Euler's totient function
**** DONE 37 A list of prime numbers

Given a range of integers by its lower and upper limit, construct a
list of all prime numbers in that range.

#+begin_src ocaml

    let all_primes a b =
      let range a b =
        let s = b - a in
        match s with
        | s when s < 0 -> []
        | 0 -> [a]
        | s -> a :: range (a+1) b in
      range a b
      |> List.filter is_prime_seive;;

    (* could be improved *)

    List.length (all_primes 2 7920)
#+end_src

#+RESULTS:
: 1000

**** TODO 38 Goldbach's conjecture
**** TODO 39 A list of Goldbach compositions
*** Logic and Codes
**** TODO 40 Truth tables for logical expressions (2 variables)
**** TODO 41 Truth tables for logical expressions
**** DONE 42 Gray code

An n-bit Gray code is a sequence of n-bit strings constructed according to certain rules. For example,

n = 1: C(1) = ['0', '1'].
n = 2: C(2) = ['00', '01', '11', '10'].
n = 3: C(3) = ['000', '001', '011', '010', '110', '111', '101',
'100'].

Find out the construction rules and write a function with the following specification: gray n returns the n-bit Gray code.

So vague...

#+begin_src ocaml :results verbatim

  let rec gray n = match n with
    | 0 -> [""]
    | n -> (List.map ((^) "0") (gray (n-1))) @
             (List.map ((^) "1") (gray (n-1) |> List.rev));;

  gray 3
#+end_src

#+RESULTS:
: - : string list = ["000"; "001"; "011"; "010"; "110"; "111"; "101"; "100"]
**** TODO 43 Huffman code
*** Trees
**** DONE 44 Completely balanced binary trees

A binary tree is either empty or it is composed of a root element and two successors, which are binary trees themselves.

In OCaml, one can define a new type ~binary_tree~ that carries an
arbitrary value of type ~'a~ (thus is polymorphic) at each node.

#+begin_src ocaml
  type 'a binary_tree =
    | Empty
    | Node of 'a * 'a binary_tree * 'a binary_tree;;
  type 'a binary_tree = Empty | Node of 'a * 'a binary_tree * 'a binary_tree
#+end_src

#+RESULTS:
: type 'a binary_tree = Empty | Node of 'a * 'a binary_tree * 'a binary_tree

An example of tree carrying ~char~ data is:

#+begin_src ocaml
  let example_tree =
    Node ('a', Node ('b', Node ('d', Empty, Empty), Node ('e', Empty, Empty)),
         Node ('c', Empty, Node ('f', Node ('g', Empty, Empty), Empty)));;
#+end_src

#+RESULTS:
: Node ('a', Node ('b', Node ('d', Empty, Empty), Node ('e', Empty, Empty)),
:    Node ('c', Empty, Node ('f', Node ('g', Empty, Empty), Empty)))

In OCaml, the strict type discipline guarantees that, if you get a value of type ~binary_tree~, then it must have been created with the two constructors ~Empty~ and ~Node~.

In a completely balanced binary tree, the following property holds for every node: The number of nodes in its left subtree and the number of nodes in its right subtree are almost equal, which means their difference is not greater than one.

Write a function ~cbal_tree~ to construct completely balanced binary
trees for a given number of nodes. The function should generate all
solutions via backtracking. Put the letter ~'x'~ as information into
all nodes of the tree.

#+begin_src ocaml :results verbatim
  let rec cbal_tree n =
    let rec outer f lst1 lst2 = match lst1 with
    | [] -> []
    | x :: xs -> (List.map (fun y -> f x y) lst2)
                 @ outer f xs lst2 in
    let join l r = Node ('x', l, r) in
    let all_joins llist rlist = (outer join llist rlist) in
    match n with
    | 0 -> [Empty]
    | 1 -> [Node('x', Empty, Empty)]
    | n when n mod 2 = 1 -> (let m = (n - 1)/2 in
                             let subtrees = cbal_tree m in
                             all_joins subtrees subtrees)
    | n -> (let a = (n-2)/2 in
            let b = a + 1 in
            let asubtrees = cbal_tree a in
            let bsubtrees = cbal_tree b in
            (all_joins asubtrees bsubtrees)
            @ (all_joins bsubtrees asubtrees));;

  [0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25]
  |> List.map cbal_tree
  |> List.map List.length
#+end_src

#+RESULTS:
: - : int list =
: [1; 1; 2; 1; 4; 4; 4; 1; 8; 16; 32; 16; 32; 16; 8; 1; 16; 64; 256; 256; 1024;
:  1024; 1024; 256; 1024; 1024]

results agree with https://oeis.org/A110316

**** DONE 45 Symmetric binary trees

Let us call a binary tree symmetric if you can draw a vertical line through the root node and then the right subtree is the mirror image of the left subtree. Write a function ~is_symmetric~ to check whether a given binary tree is symmetric.

Hint: Write a function ~is_mirror~ first to check whether one tree is the mirror image of another. We are only interested in the structure, not in the contents of the nodes.

#+begin_src ocaml
    let is_symmetric t =
      let rec is_mirror t1 t2 = match t1 with
        | Empty -> (match t2 with
                   | Empty -> true
                   | _ -> false)
        | Node (x, l1, r1) -> (match t2 with
                               | Empty -> false
                               | Node(y, l2, r2) -> (is_mirror l1 r2)
                                                    && (is_mirror l2 r1)) in
      match t with
      | Empty -> true
      | Node (x, l, r) -> is_mirror l r;;

    List.map is_symmetric (cbal_tree 9);;
#+end_src

#+RESULTS:
| false | false | false | true | false | false | true | false | false | true | false | false | true | false | false | false |

**** DONE 46 Binary search trees

Construct a binary search tree from a list of integer numbers.

#+begin_src ocaml

  let construct lst =
    let rec insert t e = match t with
      | Empty -> Node(e, Empty, Empty)
      | Node (x, left, right) when e <= x -> Node(x, insert left e, right)
      | Node (x, left, right) -> Node(x, left, insert right e) in
    let rec insert_list t lst = match lst with
      | [] -> t
      | e :: es -> insert_list (insert t e) es in
    insert_list Empty lst;;

  construct [3;2;5;7;1]
#+end_src

#+RESULTS:
: Node (3, Node (2, Node (1, Empty, Empty), Empty),
:  Node (5, Empty, Node (7, Empty, Empty)))

Then use this function to test the solution of the previous problem.

#+begin_src ocaml
  is_symmetric (construct [5; 3; 18; 1; 4; 12; 21]);;
#+end_src

#+RESULTS:
: true

#+begin_src ocaml
  not (is_symmetric (construct [3; 2; 5; 7; 4]));;
#+end_src

#+RESULTS:
: true

**** DONE 47 Generate-and-test paradigm

Apply the generate-and-test paradigm to construct all symmetric,
completely balanced binary trees with a given number of nodes.

#+begin_src ocaml :results verbatim
    let sym_cbal_tree n =
      n
      |> cbal_tree
      |> List.filter is_symmetric;;

    sym_cbal_tree 5;;

    List.length (sym_cbal_tree 57);;
#+end_src

#+RESULTS:
: - : int = 256

For ~Node (x, left, right)~ to be symmetric, ~left~ and ~right~ need
to have the same number of nodes. So there will be no symmetric trees
with an even number of nodes.

#+begin_src ocaml
    let rec range a b = match a with
      | a when a < b -> a :: (range (a+1) b)
      | a when a = b -> [b]
      | _ -> [] in
        (range 1 10)
        |> List.map (fun n -> 2*n)
        |> List.map sym_cbal_tree
        |> List.map List.length;;
#+end_src

#+RESULTS:
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

But for odd numbers?

#+begin_src ocaml
    let rec range a b = match a with
      | a when a < b -> a :: (range (a+1) b)
      | a when a = b -> [b]
      | _ -> [] in
        (range 0 24)
        |> List.map (fun n -> 2*n + 1)
        |> List.map (fun m -> (m, sym_cbal_tree m))
        |> List.map (fun (a,b) -> (a,List.length b));;
#+end_src

#+RESULTS:
|  1 |    1 |
|  3 |    1 |
|  5 |    2 |
|  7 |    1 |
|  9 |    4 |
| 11 |    4 |
| 13 |    4 |
| 15 |    1 |
| 17 |    8 |
| 19 |   16 |
| 21 |   32 |
| 23 |   16 |
| 25 |   32 |
| 27 |   16 |
| 29 |    8 |
| 31 |    1 |
| 33 |   16 |
| 35 |   64 |
| 37 |  256 |
| 39 |  256 |
| 41 | 1024 |
| 43 | 1024 |
| 45 | 1024 |
| 47 |  256 |
| 49 | 1024 |

My guess is that the number of symmetric completely balanced trees with 2n+1
nodes will be the number of completely balanced trees with n
nodes, since to be symmetric and completely balanced, it needs to be
of the form ~Node(x, left, right)~ where ~left~ is a completely
balanced tree with ~n~ nodes. But this completely determined ~right~.

#+begin_src ocaml
  let rec range a b = match a with
    | a when a < b -> a :: (range (a+1) b)
    | a when a = b -> [b]
    | _ -> [] in
      (range 0 24)
      |> List.map (fun n -> (n, 2*n+1))
      |> List.map (fun (a, b) -> (a |> cbal_tree |> List.length, b |> sym_cbal_tree |> List.length));;
#+end_src

#+RESULTS:
|    1 |    1 |
|    1 |    1 |
|    2 |    2 |
|    1 |    1 |
|    4 |    4 |
|    4 |    4 |
|    4 |    4 |
|    1 |    1 |
|    8 |    8 |
|   16 |   16 |
|   32 |   32 |
|   16 |   16 |
|   32 |   32 |
|   16 |   16 |
|    8 |    8 |
|    1 |    1 |
|   16 |   16 |
|   64 |   64 |
|  256 |  256 |
|  256 |  256 |
| 1024 | 1024 |
| 1024 | 1024 |
| 1024 | 1024 |
|  256 |  256 |
| 1024 | 1024 |

Seems right.

**** DONE 48 Construct height-balanced binary trees

In a height-balanced binary tree, the following property holds for
every node: The height of its left subtree and the height of its right
subtree are almost equal, which means their difference is not greater
than one.

Write a function ~hbal_tree~ to construct height-balanced binary trees
for a given height. The function should generate all solutions via
backtracking. Put the letter ~'x'~ as information into all nodes of the
tree.

#+begin_src ocaml :results verbatim
    let rec hbal_tree h =
      let rec outer f lst1 lst2 = match lst1 with
        | [] -> []
        | x :: xs -> (List.map (fun y -> f x y) lst2)
                     @ outer f xs lst2 in
      let join l r = Node ('x', l, r) in
      let all_joins llist rlist = (outer join llist rlist) in
      match h with
      | 0 -> [Empty]
      | 1 -> [Node('x', Empty, Empty)]
      | h -> (let one_shorter_trees = hbal_tree (h-1) in
              let two_shorter_trees = hbal_tree (h-2) in
              (all_joins one_shorter_trees one_shorter_trees)
              @ (all_joins one_shorter_trees two_shorter_trees)
              @ (all_joins two_shorter_trees one_shorter_trees));;

    List.length (hbal_tree 3)
#+end_src

#+RESULTS:
: - : int = 15

**** TODO 49 Construct height-balanced binary trees with a given number of nodes

Consider a height-balanced binary tree of height ~h~. What is the
maximum number of nodes it can contain?

The answer is definitely 2^h - 1 (just fill the tree). but confirm
this by exhaustive search for
small h values

#+begin_src ocaml
  let max_nodes h =
    let rec node_count t = match t with
      | Empty -> 0
      | Node(x, left, right) -> 1 + (node_count left) + (node_count right) in
    let rec maximum r lst = match lst with
      | [] -> r
      | x :: xs -> if (x > r)
                   then (maximum x xs)
                   else (maximum r xs) in
    h
    |> hbal_tree
    |> List.map node_count
    |> maximum 0;;

  List.map max_nodes [1;2;3;4;5]
#+end_src

#+RESULTS:
| 1 | 3 | 7 | 15 | 31 |

Seems right. But a better way would be:

#+begin_src ocaml
  let max_nodes h =
  let rec pow a b =
    match b with
    | 0 -> 1
    | b -> a * (pow a (b-1)) in
  (pow 2 h) - 1;;

List.map max_nodes [0;1;2;3;4;5]
#+end_src

#+RESULTS:
| 0 | 1 | 3 | 7 | 15 | 31 |

(could improve this further with better exponentiation, or even with bit shifting)

What about the minimum number of nodes? Brute force first, to help
make a conjecture:

#+begin_src ocaml
  let min_nodes h =
    let rec node_count t = match t with
      | Empty -> 0
      | Node(x, left, right) -> 1 + (node_count left) + (node_count right) in
    let rec minimum_acc r lst = match lst with
      | [] -> r
      | x :: xs -> if (x < r)
                   then (minimum_acc x xs)
                   else (minimum_acc r xs) in
    let max = max_nodes h in
    h
    |> hbal_tree
    |> List.map node_count
    |> minimum_acc max;;

  List.map min_nodes [0;1;2;3;4;5]
#+end_src

#+RESULTS:
| 0 | 1 | 2 | 4 | 7 | 12 |

My guess is that min_nodes h is 1 + (min_nodes (h-1)) + (min_nodes
(h-2)), with initial terms min_nodes 0 = 0 and min_nodes 1 = 1. Makes
sense if you think about trying to construct such a tree of height h
using as few nodes as possible: You'd (arbitrarily) want the left tree to have
height h-1 and the right to have height h-2, and each of them should
have as few nodes as possible. There's some combinatorial details to
check though, but here's a faster function:

#+begin_src ocaml
  let min_nodes h =
  let rec min_nodes_help a b h =
    match h with
    | 0 -> a
    | 1 -> b
    | h -> min_nodes_help (b) (a + b + 1) (h-1) in
  min_nodes_help 0 1 h;;

List.map min_nodes [0;1;2;3;4;5;6;7;8;9;10]
#+end_src

#+RESULTS:
| 0 | 1 | 2 | 4 | 7 | 12 | 20 | 33 | 54 | 88 | 143 |

Now, just need a way to generate all height-balanced trees with a
fixed number of nodes.

**** DONE 50 Collect the leaves of a binary tree in a list

A leaf is a node with no successors
Write a function ~leaves~ to collect
them in a list.

#+begin_src ocaml
  let rec leaves t = match t with
    | Empty -> []
    | Node (x, Empty, Empty) -> [x]
    | Node (x,l,r) -> (leaves l) @ (leaves r);;

  let t = Node ('0',
              Node ('1',
                    Node ('6',
                          Empty,
                          Empty),
                    Node ('3',
                      Node ('7',
                            Empty,
                            Empty),
                      Empty)),
              Node ('2',
                Node ('4',
                      Node ('8',
                            Empty,
                            Empty),
                      Node ('5',
                        Node ('9',
                              Empty,
                              Empty),
                        Empty)),
                Empty));;
leaves t;;
#+end_src

#+RESULTS:
| 6 | 7 | 8 | 9 |

**** DONE 51 Count the leaves of a binary tree

A leaf is a node with no
successors. Write a function
~count_leaves~ to count them.

#+begin_src ocaml
    let rec count_leaves t = match t with
      | Empty -> 0
      | Node(x,Empty,Empty) -> 1
      | Node(x,left,right) -> (count_leaves right)
                              + (count_leaves left);;

    count_leaves Empty;;
    count_leaves (Node('x',Node('y',Empty,Empty),Empty));;
    count_leaves t
#+end_src

#+RESULTS:
: 4

**** DONE 52 Collect the nodes at a given level in a list

A node of a binary tree is at level
N if the path from the root to the
node has length N-1. The root node
is at level 1. Write a function
~at_level t l~ to collect all nodes
of the tree ~t~ at level ~l~ in a
list.

#+begin_src ocaml
    let rec at_level t l = match l with
      | l when l < 1 -> []
      | 1 -> (match t with
              | Empty -> []
              | Node (x, l, r) -> [x])
      | l -> (match t with
              | Empty -> []
              | Node (x, left, right) -> (at_level left (l-1)) @
                                           (at_level right (l-1)));;

    at_level t 0;;
    at_level t 1;;
    at_level t 2;;
    at_level t 3;;
    at_level t 4;;
    at_level t 5;;
    at_level t 6;;

#+end_src

#+RESULTS:
: []

**** DONE 53 Collect the internal nodes of a binary tree in a list

An internal node of a binary tree
has either one or two non-empty
successors. Write a function
~internals~ to collect them in a list.

#+begin_src ocaml
        let rec internals t = match t with
          | Empty -> []
          | Node (x, Empty, Empty) -> []
          | Node (x, left, right) -> [x]
                                     @ (internals left)
                                     @ (internals right);;

      internals t
#+end_src

#+RESULTS:
| 0 | 1 | 3 | 2 | 4 | 5 |

**** TODO 54
**** TODO 55
**** TODO 56
**** TODO 57
**** TODO 58
**** TODO 59
**** TODO 60
*** Multiway trees
**** TODO 61
**** TODO 62
**** TODO 63
**** TODO 64
**** TODO 65
*** Graphs
**** TODO 66
**** TODO 67
**** TODO 68
**** TODO 69
**** TODO 70
**** TODO 71
**** TODO 72
**** TODO 73
**** TODO 74
**** TODO 75
**** TODO 76
*** Miscellaneous
**** TODO 77
**** TODO 78
**** TODO 79
**** TODO 80
**** TODO 81
**** TODO 82
**** TODO 83
**** TODO 84
**** TODO 85

** Advent of Code 2021
*** Day 1 - Sonar Sweep
**** Part 1:
Given a ~tally~ of the number of increases already seen, the
~previous~ integer from the file, and the ~in_channel~ ready to spit
out the next integer in the file:

If you're done reading the file, then ~tally~ is the
answer. Otherwise, check whether the ~next~ integer in the file is
bigger than the ~previous~ one, and recursively call ~count_increases~
with appropriately updated ~tally~ and ~previous~ parameters.

#+begin_src ocaml
    let count_increases filename =
      let input = open_in filename in
      let rec count_increases tally previous f =
        try (let next = f
                        |> input_line
                        |> int_of_string in
             match next with
             | a when a > previous -> count_increases (tally + 1) next f
             | _ -> count_increases tally next f
            ) with End_of_file -> tally in
      let first = input
                |> input_line
                |> int_of_string in
      count_increases 0 first input;;
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml :results verbatim
  count_increases "input1-1.txt"
#+end_src

#+RESULTS:
: - : int = 1215
**** Part 2:

Give a ~tally~ of how many increases you've seen so far, and also
~prev1~, ~prev2~ and ~prev3~ the three previous entries in the input,
then all that matters for updating the tally is whether the ~next~ input is bigger than ~prev1~.

#+begin_src ocaml
    let count_window_increases filename =
      let input = open_in filename in
      let rec window_increases tally prev1 prev2 prev3 f =
        try ( let next = f
                         |> input_line
                         |> int_of_string in
              match next - prev1 with
              | d when d > 0 -> window_increases (tally+1) prev2 prev3 next f
              | _ -> window_increases tally prev2 prev3 next f
            ) with End_of_file -> tally in
    let first = input
                |> input_line
                |> int_of_string in
    let second = input
                |> input_line
                |> int_of_string in
    let third = input
                |> input_line
                |> int_of_string in
    window_increases 0 first second third input;;
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml :results verbatim
  count_window_increases "input1-2.txt"
#+end_src

#+RESULTS:
: - : int = 1150
*** Day 2 - Dive!
**** Part 1

#+begin_src ocaml
  let dive filename =
    let input = open_in filename in
    let rec dive horizontal depth f =
      try (let nextline = input_line f in
           let [direction; value_str] = String.split_on_char ' ' nextline in
           let value = int_of_string value_str in
           match direction with
           | "forward" -> dive (horizontal + value) depth f
           | "up" -> dive horizontal (depth - value) f
           | "down" -> dive horizontal (depth + value) f)
      with End_of_file -> (horizontal * depth) in
  dive 0 0 input;;
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml
  dive "input2-1.txt"
#+end_src

#+RESULTS:
: 2073315

**** Part 2

#+begin_src ocaml
  let dive2 filename =
    let input = open_in filename in
    let rec dive h d a f =
      try (let nextline = input_line f in
           let [direction; x_str] = String.split_on_char ' ' nextline in
           let x = int_of_string x_str in
           match direction with
          | "up" -> dive h d (a - x) f
          | "down" -> dive h d (a + x) f
          | "forward" -> dive (h + x) (d + a*x) a f)
      with End_of_file -> (h*d) in
    dive 0 0 0 input;;
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml
  dive2 "input2-1.txt"
#+end_src

#+RESULTS:
: 1840311528

*** Day 3 - Binary Diagnostics
**** Part 1
#+begin_src ocaml

  let consumption filename =
    let len = filename
              |> open_in
              |> input_line
              |> String.length in
    let input = filename
                |> open_in in
    let rec zero_list l = match l with
      | 0 -> []
      | _ -> 0 :: zero_list (l-1) in
    let initial_tally = zero_list len in
    let rec update_tally tally bitline =
      match String.length bitline with
      | 0 -> []
      | b -> match (String.sub bitline 0 1) with
             | "1" -> (match tally with
                       | h::tl -> (h+1) :: (update_tally tl (String.sub bitline 1 (b-1))))
             | "0" -> (match tally with
                       | h::tl -> h :: (update_tally tl (String.sub bitline 1 (b-1)))) in
    let rec full_tally tl in_ch = try
        (let next_line = input_line in_ch in
         full_tally (update_tally tl next_line) in_ch)
      with End_of_file -> tl in
    let final_tally = full_tally initial_tally input in
    let rec number_of_entries count in_ch =
      try (let trash = (input_line in_ch) in number_of_entries (count+1) in_ch)
      with End_of_file -> count in 
    let entry_count = number_of_entries 0 (open_in filename) in
    let exp a p = match p with
      | 0 -> 1
      | _ -> a * exp a (p-1) in
    let rec gamma g c tally = match tally with
      | [] -> g
      | h :: tl -> match h with
                   | a when a > (entry_count/2) -> gamma (g + exp 2 (c-1)) (c-1) tl
                   | a when a < (entry_count/2) -> gamma g (c-1) tl in
    let gam = gamma 0 len final_tally in
    let eps = (exp 2 (len)) - gam - 1 in
    (gam, eps, gam*eps);;

  consumption "input3-1.txt"

#+end_src

#+RESULTS:
| 493 | 499 | 493 | 513 | 473 | 483 | 488 | 505 | 517 | 505 | 492 | 471 |

*** Day 6 - Lanternfish

Given a countdown ~c~ and a number of days ~d~, write a recursive
function for the number of lanternfish there will be after ~d~
days. Keep a cache of values to avoid exponential-time blowups.

#+begin_src ocaml
      let rec lf c d =
        let cache = Hashtbl.create 100 in
        let rec lf_mem x y =
          try
            Hashtbl.find cache [x;y]
          with
            Not_found ->
             match y with
             | 0 -> (Hashtbl.add cache [x;y] 1; 1)
             | _ -> match x with
                    | x when x > 0 -> let ans = lf_mem (x-1) (y-1) in
                                      (Hashtbl.add cache [x;y] ans; ans)
                    | _ -> (let ans = lf_mem 6 (y-1) + lf_mem 8 (y-1) in
                           (Hashtbl.add cache [x;y] ans; ans))
        in lf_mem c d;;
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml
  let lanternfish filename days =
    let rec sum = function
      | [] -> 0
      | head::tail -> head + (sum tail) in
    filename
    |> open_in
    |> input_line
    |> String.split_on_char ','
    |> List.map int_of_string
    |> List.map (fun c -> lf c days)
    |> sum;;
#+end_src
 
#+RESULTS:
: <fun>

#+begin_src ocaml
  lanternfish "input6-1.txt" 80
#+end_src

#+RESULTS:
: 354564

**** Part 2

The memoization was probably not necessary for part 1, but would have
been for part 2.

#+begin_src ocaml
  lanternfish "input6-1.txt" 256
#+end_src

#+RESULTS:
: 1609058859115

*** Day 7 - The Treachery of Whales
**** Part 1

If ~h~ is chosen horizontal position to align to, then the total fuel
consumed is the sum of ~abs(x-h)~ as ~x~ ranges over all the initial
positions specified in the input.

If you increase ~h~ by ~a~, this sum will increase by ~a~ times the number of positions
~x~ that are less than ~h~, and it will decrease by ~a~ times the
number of positions ~x~ that are greater than ~h~.

In other words, the values of ~h~ that minimized the total fuel
function is one with the same number of position values ~x~ greater
than it and less than it. This is the median of the input list if it
has odd length, and is any number between the two middle values if
the input list has even length.

So all we have to do is take the input list, find its median ~h~, and
sum ~|x-h|~ for all ~x~ in the input list

Finding the median of an unsorted list can be done in linear time, so
sorting is not optimal here.

#+begin_src ocaml

  let minimize_fuel filename =
    let input_list = filename
                     |> open_in
                     |> input_line
                     |> String.split_on_char ','
                     |> List.map int_of_string
                     |> List.sort (fun a b -> a - b) in
    let median = List.nth input_list ((List.length input_list)/2) in
    let rec fuelsum list h partial =
      match list with
      | [] -> partial
      | x::t -> fuelsum t h (partial + abs(x - h)) in
    fuelsum input_list median 0;;

  minimize_fuel "input7-1.txt"
#+end_src

#+RESULTS:
: 323647

*** Day 10 - Syntax Scoring
**** Part 1

To check whether a string is balanced or not, use a stack. Push
opening characters onto the stack. When closing characters are
encountered, pop the stack if it matches. Otherwise, that's the first
incorrect character. If you get to the end of the string and the stack
is empty, it's a balanced expression. But if you get to the end of the
string and the stack still has characters, it's incomplete
*** Day 14 - Polymerization

I don't love how messy this is, might want to come back to it later
and clean it up. A lot of hashtables and imperative trickery. Not very functional.

#+begin_src ocaml :results verbatim
  let polymerization filename =
    let inpt = open_in filename in
    let rec stringlist_from_in_ch ch =
      try (let line = input_line ch
           in line :: stringlist_from_in_ch ch)
      with End_of_file -> [] in
    let lines = stringlist_from_in_ch inpt in
    let initial_string = List.hd lines in
    let rec list_of_string s = match String.length s with
      | 0 -> []
      | n -> (String.sub s 0 1) :: list_of_string (String.sub s 1 (n-1)) in
    let initial_list = list_of_string initial_string in
    let rule_strings = lines |> List.tl |> List.tl in
    let num_rules = List.length rule_strings in
    let rule_hashtbl = Hashtbl.create num_rules in
    let rule_of_string s = 
      let k = String.sub s 0 2 in
      let v = String.sub s 6 1 in
      Hashtbl.add rule_hashtbl k v in
    ignore(List.map rule_of_string rule_strings);
    let rec apply_rules lst h = match lst with
      | [] -> []
      | [c] -> [c]
      | a :: b :: cs -> if (Hashtbl.mem h (a^b))
                        then (let x = Hashtbl.find h (a^b) in
                              a :: x :: (apply_rules (b :: cs) h))
                        else (a :: (apply_rules (b :: cs) h)) in
    let mut_list = ref initial_list in
    let i = ref 0 in
    while (!i < 10)
    do (mut_list := apply_rules (!mut_list) rule_hashtbl; i := !i+1)
    done;
    let t = Hashtbl.create (List.length !mut_list) in
    let rec tally lst = match lst with
      | [] -> t
      | x :: xs -> (if (Hashtbl.mem t x)
                    then (Hashtbl.replace t x (1 + (Hashtbl.find t x)))
                    else (Hashtbl.add t x 1); tally xs) in
    ignore(tally !mut_list);
    let most_common = Hashtbl.fold (fun k v m -> max v m) t 0 in
    let least_common = Hashtbl.fold (fun k v m -> min v m) t (List.length !mut_list) in
    most_common - least_common;;

    polymerization "input14-1.txt"
#+end_src

#+RESULTS:
: - : string = "C"

*** Day 18 - Snailfish numbers
**** Part 1
