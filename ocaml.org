#+STARTUP: content

* Learning OCaml - notes

This is the notes file accompanying my attempt to learn ocaml.

** Goals
+ Learning OCaml.
+ Literate programming in org-mode.
** Notes on OCaml in org-mode

These variables control something about the way code gets
passed to and retrieved from the ocaml toplevel that emacs runs in the
background. The toplevel can look a little cluttered with this
expression repeated all over the place, but it's probably not worth changing.

#+begin_example emacs-lisp
  ;; (setq org-babel-ocaml-eoe-output "org-babel-ocaml-eoe")
  ;; (setq org-babel-ocaml-eoe-indicator "\"org-babel-ocaml-eoe\";;")

  (setq org-babel-ocaml-eoe-output "org-babel-ocaml-eoe")
  (setq org-babel-ocaml-eoe-indicator "\"org-babel-ocaml-eoe\";;")
#+end_example

The default behavior of source blocks may not be adequate for printing
results. For example the following source block shows its result, but
does not show the type of the result:

#+begin_src ocaml
    let x = 42;;
    x
#+end_src

#+RESULTS:
: 42

But with the verbatim tag, the type is displayed as well.

#+begin_src ocaml :results verbatim
    let x = 42;;
    x
#+end_src

#+RESULTS:
: - : int = 42

And in this source block, when a string printing function is called,
the printed string doesn't manage to make it to the results
line. Again, the verbatim tag seems fixes this

#+begin_src ocaml :results verbatim
print_string "hello\n"
#+end_src

#+RESULTS:
: hello
: - : unit = ()

There is also the ~:results output~ tag. This is similar to ~:results
verbatim~ but it deosn't seem to handle multi-line input:

#+begin_src ocaml :results output
print_string "hello\n"
#+end_src

#+RESULTS:
: hello

In the event that source blocks aren't sufficient, you can open the
actual running toplevel with ~M-x tuareg-run-ocaml~ and interact with
it directly.

** CS3110 - notes and exercises

#+begin_src ocaml
  let x = 42;;
#+end_src

#+RESULTS:
val x : int = 42

#+begin_src ocaml
  (fun x -> x + 3) 4;;
#+end_src

#+RESULTS:
: 7

*** Basics - Exercises:
**** Values

What is the type and value of each of the following OCaml expressions:

+ ~7 * (1 + 2 + 3)~
+ ~"CS " ^ string_of_int 3110~

The first is ~42 : int~, the second is ~CS 3110 : string~

#+begin_src ocaml results: output
7 * (1 + 2 + 3)
#+end_src

#+RESULTS:
: 42

#+begin_src ocaml
  "CS " ^ string_of_int 3110
#+end_src

#+RESULTS:
: CS 3110
**** Operators

+ Write an expression that multiplies 42 by 10
+ Write an expression that divides 3.14 by 2.0
+ Write an expression that computes 4.2 raised to the 7th power

  #+begin_src ocaml
    42 * 10
  #+end_src

  #+RESULTS:
  : 420

  #+begin_src ocaml
    3.14 /. 2.0
  #+end_src

  #+RESULTS:
  : 1.57

  #+begin_src ocaml
    let rec pow a b = match b with
      | 0 -> 1.0
      | b -> a *. pow a (b-1) in
        pow 4.2 7
  #+end_src

  #+RESULTS:
  : 23053.933324800008
**** Equality

+ Write an expression that compares ~42~~ to ~42~ using structural equality
+ Write an expression that compares ~"hi"~ to ~"hi"~ using structural
  equality. What is the result?
+ Write an expression that compares ~"hi"~ to ~"hi"~ using physical
  equality. What is the result?


Structural equality is compared with ~=~ (or ~<>~ for inequality)

#+begin_src ocaml
  42 = 42
#+end_src

#+RESULTS:
: true

#+begin_src ocaml
  "hi" = "hi"
#+end_src

#+RESULTS:
: true

Physical equality is compared with ~==~ and ~!=~.
#+begin_src ocaml
  "hi" == "hi"
#+end_src

#+RESULTS:
: false

structural equality is closer to the mathematical notion of equality,
but physical equality is closer to "are these the same object in
memory?". Probably usually better to use ~=~.
**** Assertions

+ Enter ~assert true;;~ into utop and see what happens.
+ Enter ~assert false;;~ into utop and see what happens.
+ Write an expression that asserts 2110 is not (structurally) equal
  to 3110.

  ~assert true;;~ seems to do "nothing" with type unit. Assert false
  throws an exception (Assert_failure)

  #+begin_src ocaml
    assert (2110 <> 3110);;
  #+end_src

  #+RESULTS:
  : ()
**** If

Write an if expression that evaluates to 42 if 2 is greater than 1 and
otherwise evaluates to 7.

#+begin_src ocaml
  if 2 > 1 then 42 else 7;;
#+end_src

#+RESULTS:
: 42

**** Double fun
Using the increment function from above as a guide, define a function
double that multiplies its input by 2. For example, double 7 would
be 14. Test your function by applying it to a few inputs. Turn those
test cases into assertions.

#+begin_src ocaml results: verbatim

  let double x = 2 * x;;

  double 7;;
  double 100;;
  double (-5);;

  assert (double 20 = 2*20);;
  assert (double 0 = 0)
#+end_src

#+RESULTS:
: ()

**** More fun

+ Define a function that computes the cube of a floating-point number. Test your function by applying it to a few inputs.
+ Define a function that computes the sign (1, 0, or -1) of an integer. Use a nested if expression. Test your function by applying it to a few inputs.
+ Define a function that computes the area of a circle given its
  radius. Test your function with assert.

  #+begin_src ocaml
    let cube x = x *. x *. x;;

    cube 1.5;;
    cube 2.1;;
    cube Float.pi;;
  #+end_src

  #+RESULTS:
  : 31.006276680299816

#+begin_src ocaml

    let sgn x = match x with
      | 0 -> 0
      | x -> if x > 0 then 1 else -1;;

    sgn 2;;
    sgn 4;;
    sgn (-1 * 5);;
    sgn 0
#+end_src

#+RESULTS:
: 0

#+begin_src ocaml
  let area r =
    let pi = Float.pi in
    pi *. r *. r;;

  area 1.0;;
  area 2.0;;

assert (area 1.0 -. Float.pi < 1e-5)
#+end_src

#+RESULTS:
: ()

**** RMS

Define a function that computes the root mean square of two
numbers—i.e.
\[\sqrt{x^2 + y^2}\]
Test your function with assert.

#+begin_src ocaml
  let rms x y = Float.sqrt(x *. x +. y *. y);;

  rms 3. 4.;;
  rms 5. 12.;;
  rms 7399. 10200.;;
#+end_src


test with pythagorean triples

#+begin_src ocaml
    let rmstest s t =
      let a = 2. *. s *. t in
      let b = s *. s -. t *. t in
      let c = s *. s +. t *. t in
      assert (rms a b -. c < 1e-8);;

    rmstest 10. 21.;;
    rmstest 1000. 3201.;;
#+end_src

#+RESULTS:
: ()

**** date fun

Define a function that takes an integer d and string m as input and returns true just when d and m form a valid date. Here, a valid date has a month that is one of the following abbreviations: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sept, Oct, Nov, Dec. And the day must be a number that is between 1 and the minimum number of days in that month, inclusive. For example, if the month is Jan, then the day is between 1 and 31, inclusive, whereas if the month is Feb, then the day is between 1 and 28, inclusive.

How terse (i.e., few and short lines of code) can you make your
function? You can definitely do this in fewer than 12 lines.

(it's not clear to me why this is a "three star" exercise. Am I
supposed to to this with a hash table or something?
#+begin_src ocaml
  let valid_date d m =
    match d with
    | "Feb" -> m <= 28
    | "Sept" | "Apr" | "Jun" | "Nov" -> m <= 30
    | "Jan" | "Mar" | "May" | "Jul" | "Aug" | "Oct" | "Dec" -> m <= 31
    | _ -> false;;

  valid_date "Apr" 20
#+end_src

#+RESULTS:
: true

**** fib fun

Define a recursive function ~fib : int -> int~, such that ~fib n~ is
the nth number in the Fibonacci sequence, which is 1, 1, 2, 3, 5, 8,
13, … That is

+ ~fib 1 = 1~
+ ~fib 2 = 1~
+ ~fib n = fib (n-1) + fib (n-2)~ for ~n > 2~

#+begin_src ocaml
  let rec fib n = match n with
    | 1 | 2 -> 1
    | n -> fib (n-1) + fib (n-2);;

  List.map fib [1;2;3;4;5;6;7;8;9;10]
#+end_src

  #+RESULTS:
  | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 |

**** fib fast

How quickly does your implementation of fib compute the 50th Fibonacci
number? If it computes nearly instantaneously, congratulations! But
the recursive solution most people come up with at first will seem to
hang indefinitely. The problem is that the obvious solution computes
subproblems repeatedly. For example, computing fib 5 requires
computing both fib 3 and fib 4, and if those are computed separately,
a lot of work (an exponential amount, in fact) is being redone.

#+begin_src ocaml results: verbatim
    let fibtimer n = 
      let t1 = Sys.time() in
      let fn = fib n in
      let t2 = Sys.time() in
      let output = "found fib "
                   ^ (string_of_int n)
                   ^ " = "
                   ^ (string_of_int fn)
                   ^ " in "
                   ^ (string_of_float (t2 -. t1))
                   ^ " seconds." in
      print_endline output;;

    fibtimer 50;;
#+end_src

#+RESULTS:
: ()

Prints ~found fib 50 = 12586269025 in 257.446328 seconds~. Slow.

#+begin_src ocaml

    let fib_fast n =
      let rec fibhelp a b n = match n with
        | 1 -> a
        | n -> fibhelp b (a+b) (n-1) in
      fibhelp 1 1 n;;

  let fibfasttimer n = 
    let t1 = Sys.time() in
    let fn = fib_fast n in
    let t2 = Sys.time() in
    let output = "found fib_fast "
                 ^ (string_of_int n)
                 ^ " = "
                 ^ (string_of_int fn)
                 ^ " in "
                 ^ (string_of_float (t2 -. t1))
                 ^ " seconds." in
    print_endline output;;

  fibfasttimer 50;;
#+end_src

#+RESULTS:
: ()

Prints ~found fib_fast 50 = 12586269025 in 4.99999998738e-06
seconds.~, much faster.

What is the first value of n for which fib_fast n is negative,
indicating that integer overflow occurred?

#+begin_src ocaml
  let first_overflow =
    let rec next_neg_fib n =
      if (fib_fast n < 0) then (n) else (next_neg_fib (n+1)) in
    next_neg_fib 1
#+end_src

#+RESULTS:
: 91

**** poly types

What is the type of each of the functions below? You can ask the
toplevel to check your answers

+ let f x = if x then x else x
+ let g x y = if y then x else x
+ let h x y z = if x then y else z
+ let i x y z = if x then y else y

  ~let f x = if x then x else x~: Since ~x~ is being passed as the first
  argument to the ternary if-then-else, it has to be a boolean. Since
  the output is always ~x~, the output of ~f~ will be boolean. So ~f~
  is a function ~bool -> bool~.

  ~let g x y = if y then x else x~: Here, ~y~ needs to be boolean. But
  ~x~ can have arbitrary type ~T~. The output of the function will
  have the same type as ~x~ (in fact it will be ~x~), so ~g~ is a function
  that takes an argument of type ~T~ and an argument of type bool and
  returns an output of type ~T~. i.e. ~g: T -> bool -> T~. Ocaml uses
  ~'a~ for this type variable.

  ~let h x y z = if x then y else z~: Again, ~x~ needs to have type
  ~bool~. Since the ~then ()~ and ~else ()~ branches needs to have the
  same output type, ~y~ and ~z~ need to have the same arbitrary type
  ~T~. So ~h : bool -> T -> T -> T~

  ~let i x y z = if x then y else y~: Here, ~x~ need to have type
  ~bool~. ~y~ can have arbitrary type ~T1~, and ~z~ can have arbitrary
  type ~T2~. The output is always ~y~, which will have type ~T1~. So
  ~i: bool -> T1 -> T2 -> T1~

**** Divide

Write a function divide : numerator:float -> denominator:float ->
float. Apply your function.

#+begin_src ocaml
    let divide num denom =
      let q = num /. denom in
      match q with
      | q when q = infinity -> raise Division_by_zero
      | q when q = neg_infinity -> raise Division_by_zero
      | q when compare q nan = 0 -> raise Division_by_zero
      | q -> q;;

    divide 0. 0.
#+end_src

#+RESULTS:
: Exception: Division_by_zero.

(weirdly, ~nan = nan~ is false, so you need to use the compare in that
case)

**** Associativity

Suppose that we have defined ~let add x y = x + y~. Which of the
following produces an integer, which produces a function, and which
produces an error? Decide on an answer, then check your answer in the
toplevel.

+ ~add 5 1~
  This is ~add~ applied to two arguments. It evaluates to ~~5+1 = 6~. 
+ ~add 5~
  This is ~add~ applied to one argument. It is the "add five" function.
+ ~(add 5) 1~
  This is the "add five" function, appled to ~1~. It evaluates to ~6~.
+ ~add (5 1)~
  This will produce an error. In fact, just (5 1) by itself will
  produce an error, since ~5~ is not a function, so it can't be
  applied to ~1~.

**** Average

Define an infix operator ~+/.~ to compute the average of two
floating-point numbers. For example,

+ ~1.0 +/. 2.0 = 1.5~
+ ~0. +/. 0. = 0.~

  #+begin_src ocaml
    let (+/.) a b = (a +. b) /. 2.;;

     1.0 +/. 2.0;;
     0. +/. 0. ;;
  #+end_src

  #+RESULTS:
  : 0

**** Hello World

Type the following in utop, and notice the difference in output from
each:

+ ~print_endline "Hello world!";;~
  Prints the string, with a carriage return at the end. Has type
  ~unit~. Output looks like:

  #+begin_export ascii
  Hello world!
  - : unit = ()
  #+end_export
  
+ ~print_string "Hello world!";;~
  Prints the string with no newline. Has type unit. Output looks like:

  #+begin_export ascii
  Hello world!- : unit = ()
  #+end_export

*** Data and Types - Exercises

**** List Expressions
+ Construct a list that has the integers 1 through 5 in it. Use the
  square bracket notation for lists.
  
  #+begin_src ocaml
    let l1 = [1;2;3;4;5];;
  #+end_src

  #+RESULTS:
  | 1 | 2 | 3 | 4 | 5 |
  
+ Construct the same list, but do not use the square bracket
  notation. Instead use ~::~ and ~[]~.

  #+begin_src ocaml
    let l2 = 1::2::3::4::5::[];;
  #+end_src

  #+RESULTS:
  | 1 | 2 | 3 | 4 | 5 |

+ Construct the same list again. This time, the following expression
  must appear in your answer: ~[2; 3; 4]~. Use the @ operator, and do
  not use ~::~

  #+begin_src ocaml
    let l3 = [1] @ [2;3;4] @ [5];;
  #+end_src

  #+RESULTS:
  | 1 | 2 | 3 | 4 | 5 |

**** Product

Write a function that returns the product of all the elements in a
list. The product of all the elements of an empty list is ~1~.

#+begin_src ocaml

  let list_product l =
    let rec list_product_acc p l = match l with
      | [] -> p
      | x :: xs -> list_product_acc (p*x) xs in
    list_product_acc 1 l;;

  list_product (l1 @ l2 @ l3)
#+end_src

#+RESULTS:
: 1728000

**** concat

Write a function that concatenates all the strings in a list. The
concatenation of all the strings in an empty list is the empty string
"".

#+begin_src ocaml

    let list_concat l =
      let rec list_concat_acc s l = match l with
        | [] -> s
        | x :: xs -> list_concat_acc (s^x) xs in
      list_concat_acc "" l;;

    list_concat ["Hel"; "lo"; ","; " ";"world";"!"]
#+end_src

#+RESULTS:
: Hello, world!

**** TODO product test

Unit test the function product that you wrote in an exercise above.

**** Patterns

Using pattern matching, write three functions, one for each of the following properties. Your functions should return true if the input list has the property and false otherwise.

+ the list’s first element is "bigred"

  #+begin_src ocaml
    let bigred l = match l with
    | "bigred" :: xs -> true
    | _ -> false;;

    bigred ["smallred"];;
    bigred ["bigred";"x";"y";"z"]
  #+end_src

  #+RESULTS:
  : true

(I'm not sure how to make this polymorphic: if the first element is an
integer, I get a type error

+ the list has exactly two or four elements; do not use the length
  function

  #+begin_src ocaml
        let two_or_four l = match l with
          | x::y::[] -> true
          | x::y::z::w::[] -> true
          | _ -> false;;

        two_or_four [1;2;3;4];;
        two_or_four ["a";"b"]
  #+end_src

  #+RESULTS:
  : true
  
+ the first two elements of the list are equal

  #+begin_src ocaml
        let first_two_equal l = match l with
        | x::y::xs when x = y -> true
        | _ -> false;;

        first_two_equal [1;2;3];;
        first_two_equal [[1];[1];[1;2]];;
        first_two_equal [[];[];[1;2]];;
        first_two_equal ([[]]::[[]]::[]);;
  #+end_src

  #+RESULTS:
  : true
  
**** Library

Consult the List standard library to solve these exercises:

+ Write a function that takes an int list and returns the fifth
  element of that list, if such an element exists. If the list has
  fewer than five elements, return 0. Hint: List.length and List.nth.

  #+begin_src ocaml
        let fifth_element l =
          if (List.length l >= 5) then (List.nth l 4) else (0);;

        fifth_element [1;2;3;4;5;6;7;8;9];;
        fifth_element [8;7;6;5;4];;
        fifth_element [1]
  #+end_src

  #+RESULTS:
  : 0

+ Write a function that takes an int list and returns the list sorted
in descending order. Hint: List.sort with Stdlib.compare as its
first argument, and List.rev.
  
#+begin_src ocaml
  let descending_sort l = l
                    |> List.sort Stdlib.compare
                    |> List.rev;;

  descending_sort [1;4;3;2;3;4;3;1;10;23;14]
#+end_src

#+RESULTS:
| 23 | 14 | 10 | 4 | 4 | 3 | 3 | 3 | 2 | 1 | 1 |

**** TODO Library Tests

Write a couple OUnit unit tests for each of the functions you wrote in
the previous exercise

**** Library Puzzle

+ Write a function that returns the last element of a list. Your
  function may assume that the list is non-empty. Hint: Use two
  library functions, and do not write any pattern matching code of
  your own.

#+begin_src ocaml
  let last_element l = List.nth l (List.length l - 1);;

  last_element [1;4;3;2;3;7];;
#+end_src

#+RESULTS:
: 7

+ Write a function ~any_zeroes : int list -> bool~ that returns ~true~
  if and only if the input list contains at least one ~0~. Hint: use
  one library function, and do not write any pattern matching code
  of your own.

  #+begin_src ocaml
        let any_zeroes l = List.exists ((=) 0) l;;

        any_zeroes [1;2;3;4;10];;
        any_zeroes [1;2;3;-1;-2;-10];;
        any_zeroes [];;
        any_zeroes [1;1;1;1;0;1;1;2;2;3;3;4]
  #+end_src

  #+RESULTS:
  : true

**** Take Drop

+ Write a function take : int -> 'a list -> 'a list such that take n
  lst returns the first n elements of lst. If lst has fewer than n
  elements, return all of them.

#+begin_src ocaml

    let rec take n l = match n with
      | 0 -> []
      | n -> (match l with
              | x :: xs -> x::(take (n-1) xs)
              | [] -> []);;

    take 2 [5;4;3;2;1];;
    take 3 [1;2];;
    take 0 [1;2];;
    take 0 [];;
#+end_src

#+RESULTS:
: []

+ Write a function drop : int -> 'a list -> 'a list such that drop n
  lst returns all but the first n elements of lst. If lst has fewer
  than n elements, return the empty list.

  #+begin_src ocaml
    let rec drop n l = match n with
    | 0 -> l
    | n -> (match l with
          | x :: xs -> drop (n-1) xs
          | [] -> []);;

    drop 3 [1;2;3;4;5;6;7;8];;
    drop 2 [1];;
    drop 3 [5;4;4];;
    drop 0 [1;2;3]
  #+end_src

  #+RESULTS:
  | 1 | 2 | 3 |

**** TODO Take Drop Tail

Revise your solutions for take and drop to be tail recursive, if they
aren’t already. Test them on long lists with large values of n to see
whether they run out of stack space. To construct long lists, use the
~--~ operator from the lists section.

**** Unimodal

Write a function is_unimodal : int list -> bool that takes an integer
list and returns whether that list is unimodal. A unimodal list is a
list that monotonically increases to some maximum value then
monotonically decreases after that value. Either or both segments
(increasing or decreasing) may be empty. A constant list is unimodal,
as is the empty list.

#+begin_src ocaml
    let rec is_unimodal l =
      let rec is_nonincreasing l = match l with
      | [] -> true
      | x :: [] -> true
      | a :: b :: tail -> if (a < b)
                          then (false)
                          else (is_nonincreasing (b :: tail)) in
      match l with
      | [] -> true
      | x :: [] -> true
      | a :: b :: [] -> true
      | a :: b :: tail -> if (a <= b)
                          then (is_unimodal (b :: tail))
                          else (is_nonincreasing (b :: tail));;

    is_unimodal [1;2;2;2;3;3;2;2];;
    is_unimodal [1;2;3;4;4;4;5];;
    is_unimodal [6;5;4;3;2;1];;
    is_unimodal [1;2;3;3;2;1;2];;
    is_unimodal [1;1;1;1;1];;
    is_unimodal [0;0;0;0;0;0;0;0;1];;
    is_unimodal [1;0;0;0;0;0;0;0;0;0];;
    is_unimodal [4]
#+end_src

#+RESULTS:
: true

*** Higher-Order Programming - Exercises
**** Twice, no arguments

Consider the following definitions. Use the toplevel to determine what the types of quad and fourth are. Explain how it can be that quad is not syntactically written as a function that takes an argument, and yet its type shows that it is in fact a function.

#+begin_src ocaml :results verbatim
  let double x = 2*x
#+end_src

#+RESULTS:
: val double : int -> int = <fun>

#+begin_src ocaml :results verbatim
  let square x = x*x
#+end_src

#+RESULTS:
: val square : int -> int = <fun>

#+begin_src ocaml :results verbatim
  let twice f x = f (f x)
#+end_src

#+RESULTS:
: val twice : ('a -> 'a) -> 'a -> 'a = <fun>

#+begin_src ocaml :results verbatim
  let quad = twice double
#+end_src

~double~ is a function of type ~int -> int~, while ~twice~ is
(polymorphically) a function that takes a function of type ~T -> T~
and produces a new function of type ~T -> T~. So when applied to
~double~, it gives a new function ~int -> int~.

Can also think of it in terms of currying: ~twice f x~ means ~f (f
x)~, so ~twice f~ is a function still waiting for its last argument.

#+RESULTS:
: val quad : int -> int = <fun>

#+begin_src ocaml :results verbatim
  let fourth = twice square
#+end_src

#+RESULTS:
: val fourth : int -> int = <fun>

The same description of ~twice double~ applies to ~twice square~ as
well, since ~double~ and ~square~ have the same type.
**** Mystery Operator 1

What does the following operator do?

#+begin_src ocaml
    let ( $ ) f x = f x;;



    double $ 3 + 1;;

    ($) (double) (3 + 1) ;;

#+end_src

#+RESULTS:
: 8

~$~ is an infix operator that applies its left argument to its right
argument. So ~f $ x~ evaluates to ~f x~. But because of the precedence
of operator binding, ~double 3 + 1~ is ~(double 3) + 1~, which is
~7~. But ~double $ 3 + 1~ is ~($) (double) (3 + 1)~, which is ~8~

**** Mystery Operator 2

What does the following operator do?

#+begin_src ocaml
  let ( @@ ) f g x = x |> g |> f;;

  (String.length @@ string_of_int) 10;
#+end_src

#+RESULTS:
: Line 2, characters 0-35:
: 2 | (String.length @@ string_of_int) 10;
:     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
: Warning 10 [non-unit-statement]: this expression should have type unit.
: Line 3, characters 0-13:
: 3 | String.length string_of_int 10;;
:     ^^^^^^^^^^^^^
: Error: This function has type string -> int
:        It is applied to too many arguments; maybe you forgot a `;'.

~@@~ is an "infix" (sort of) operator, where ~f @@ g~ is a function
that, when applied to ~x~, give ~f (g x)~ (as opposed to ~f g
x~). This is function composition.

**** Repeat

Generalize ~twice~ to a function ~repeat~, such that ~repeat f n x~ applies ~f~ to ~x~ a total of ~n~ times.

#+begin_src ocaml
    let rec repeat f n x = match n with
      | 0 -> x
      | n -> f (repeat f (n-1) x);;

    repeat double 10 1;;
#+end_src

#+RESULTS:
: 1024

**** Product

Use ~fold_left~ to write a function ~product_left~ that computes the product of a list of floats. The product of the empty list is ~1.0~. Hint: recall how we implemented sum in just one line of code in lecture.

~fold left~ is defined below. For a specific binary function ~f~, a starting
"accumulation" value ~a~ and a list like (for example) ~[1;2;3]~, it
gives ~f (f (f a 1) 2) 3~. If the binary function is multiplication
and the initial accumulation value is ~1~, you'll get the product of
the elements in the list.

#+begin_src ocaml
  let rec fold_left f acc = function
    | [] -> acc
    | h :: t -> fold_left f (f acc h) t;;

  let product_left = fold_left ( * ) 1;;

  product_left [1;2;3;4]
#+end_src

#+RESULTS:
: 24

Use ~fold_right~ to write a function ~product_right~ that computes the product of a list of floats. Same hint applies

Again, ~fold_right~ is defined below: Given ~f~, ~a~ and ~[1;2;3]~ as
above, you'd get ~f 1 (f 2 (f 3 a))~.

I think the only difference here is that you "need" (probably a way
around it though) to specificy the list argument to ~product_right~.

#+begin_src ocaml
  let rec fold_right f lst acc = match lst with
    | [] -> acc
    | h :: t -> f h (fold_right f t acc);;

  let product_right lst = fold_right ( * ) lst 1;;

  product_right [1;2;3;4;5]
#+end_src

#+RESULTS:
: <fun>

**** Terse Product

How terse can you make your solutions to the ~product~ exercise?
Hints: you need only one line of code for each, and you do not need
the ~fun~ keyword. For ~fold_left~, your function definition does not
even need to explicitly take a list argument. If you use ~ListLabels~,
the same is true for ~fold_right~.

I think my product_left is about as terse as possible already. To
eliminate the argument from the left hand side of product_right, you
could do:

#+begin_src ocaml
    let rec fold_right ~fn:f ~list:lst ~a:acc = match lst with
      | [] -> acc
      | h :: t -> f h (fold_right ~fn:f ~list:t ~a:acc)

    let product_right_terse = fold_right ~fn:( * ) ~a:1;;

    product_right_terse [1;2;3;4;5;6]
#+end_src

#+RESULTS:
: 720

(should figure out exactly the syntax and conventions for labelled
argument, since I don't feel like I did this exactly the right way.)

**** sum cube odd

Write a function ~sum_cube_odd n~ that computes the sum of the cubes
of all the odd numbers between ~0~ and ~n~ inclusive. Do not write any
new recursive functions. Instead, use the functionals ~map~, ~fold~,
and ~filter~, and the ~( -- )~ operator (defined in the discussion of
pipelining).

The infix range operator from earlier in the chapter:
#+begin_src ocaml
  let rec ( -- ) i j = if i > j then [] else i :: i + 1 -- j;;
#+end_src

#+begin_src ocaml

  let sum_cube_odd n =
    let odd m = m mod 2 = 1 in
    let cube x = x * x * x in
    (1 -- n)
    |> List.filter odd
    |> List.map cube
    |> List.fold_left (+) 0 ;;

  sum_cube_odd 10
#+end_src

#+RESULTS:
: 1225

**** sum cube odd pipeline

Rewrite the previous function with the pipeline ~|>~ operator. (I
already used it a fair bit in the previous, But I guess with even
fewer inner ~let~ statements and more pipelininig it could be written:

#+begin_src ocaml
    let sum_cube_odd_pipeline n =
      n
      |> (--) 1
      |> List.filter (fun m -> m mod 2 = 1)
      |> List.map (fun x -> x * x * x)
      |> List.fold_left (+) 0 ;;

  sum_cube_odd_pipeline 10
#+end_src

#+RESULTS:
: 1225

* Learning OCaml - problems
** 99 OCaml Problems
*** Checklist
| Nummber | Description            | Status |
|---------+------------------------+--------|
|       1 | last_element           | done   |
|       2 | last_two               | done   |
|       3 | kth_element            | done   |
|       4 | list length            | done   |
|       5 | reverse                | done   |
|       6 | palindrome             | done   |
|       7 | flatten                |        |
|       8 | delete duplicates      |        |
|       9 | pack                   |        |
|      10 | run-length             |        |
|      11 | run-length mod         |        |
|      12 | run-length decode      |        |
|      13 | run-length direct      |        |
|      14 | duplicate elts         |        |
|      15 | replicate elts         |        |
|      16 | drop every nth         |        |
|      17 | split list             |        |
|      18 | list slice             |        |
|      19 | rotate n left          |        |
|      20 | remove kth             |        |
|      21 | insert                 |        |
|      22 | create range           |        |
|      23 | extract random         |        |
|      24 | lotto                  |        |
|      25 | random permutation     |        |
|      26 | k choose n             |        |
|      27 | partitions             |        |
|      28 | sort by length         |        |
|      29 | -                      |        |
|      30 | -                      |        |
|      31 | prime                  |        |
|      32 | gcd                    |        |
|      33 | coprime                |        |
|      34 | euler phi              |        |
|      35 | prime factors          |        |
|      36 | prime factors 2        |        |
|      37 | euler phi 2            |        |
|      38 | compare euler phis     |        |
|      39 | prime list             |        |
|      40 | goldbach               |        |
|      41 | goldbach list          |        |
|      42 | -                      |        |
|      43 | -                      |        |
|      44 | -                      |        |
|      45 | -                      |        |
|      46 | truth tables 1         |        |
|      47 | truth tables 2         |        |
|      48 | truth tables 3         |        |
|      49 | gray code              |        |
|      50 | huffman code           |        |
|      51 | -                      |        |
|      52 | -                      |        |
|      53 | -                      |        |
|      54 | -                      |        |
|      55 | balanced binary tree   |        |
|      56 | symmetric binary tree  |        |
|      57 | binary search tree     |        |
|      58 | generate and test      |        |
|      59 | height balanced tree   |        |
|      60 | height balanced tree 2 |        |
|      61 | count leaves           |        |
|     61A | collect leaves in list |        |
|      62 | collect internal nodes |        |
|     62B | collect nodes at level |        |
|      63 | complete binary tree   |        |
|      64 | layout binary tree     |        |
|      65 | layout binary tree 2   |        |
|      66 | layout binary tree 3   |        |
|      67 | string rep tree        |        |
|      68 | seqeuences of trees    |        |
|      69 | dotstring of tree      |        |
|     70C | nodes of multiway tree |        |
|      70 | tree from node string  |        |
|      71 | internal path length   |        |
|      72 | bottom up order        |        |
|      73 | lisp tree rep          |        |
|      74 | -                      |        |
|      75 | -                      |        |
|      76 | -                      |        |
|      77 | -                      |        |
|      78 | -                      |        |
|      79 | -                      |        |
|      80 | conversions            |        |
|      81 | paths                  |        |
|      82 | cycles                 |        |
|      83 | all spanning           |        |
|      84 | min spanning           |        |
|      85 | graph isomorphism      |        |
|      86 | node degree + color    |        |
|      87 | depth first traverse   |        |
|      88 | connected components   |        |
|      89 | bipartite              |        |
|      90 | k regular n node       |        |
|      91 | eight queens           |        |
|      92 | knights tour           |        |
|      93 | von koch               |        |
|      94 | arithmetic puzzle      |        |
|      95 | number words           |        |
|      96 | syntax checker         |        |
|      97 | sudoku                 |        |
|      98 | nonograms              |        |
|      99 | crossword              |        |

*** 1
Write a function ~last : 'a list -> 'a option~ that returns the last
element of a list.

#+begin_src ocaml

    let rec last lst = match lst with
      | [] -> None
      | x :: [] -> Some x
      | x :: xs -> last xs;;

    last [1;2;3];;
    last [1];;
    last []
#+end_src

#+RESULTS:
: None
*** 2

Find the last but one (last and penultimate) elements of a list.

#+begin_src ocaml

    let rec last_two lst = match lst with
      | [] -> None
      | x :: [] -> None
      | x :: y :: [] -> Some (x, y)
      | x :: xs -> last_two xs;;

    last_two [1;3;2;4;3;2;3];;
    last_two [1;3];;
    last_two [1];;
    last_two []
#+end_src

#+RESULTS:
: None

*** 3

Find the K^{th} element of a list.

This one requires the parentehses around the inner ~match~
expressions. Otherwise, it thinks ~m~ is of type ~'a list~.

#+begin_src ocaml
  let rec at n lst = match n with
    | 0 -> None
    | 1 -> (match lst with
            | [] -> None
            | x :: xs -> Some x)
    | m -> (match lst with
            | [] -> None
            | x :: xs -> at (m - 1) xs);;

  at 3 [1;2;3;4;5]
#+end_src

#+RESULTS:
: Some 3

*** 4
Find the number of elements of a list

#+begin_src ocaml

    let length lst =
      let rec length_acc i lst = match lst with
        | [] -> i
        | x :: xs -> length_acc (i + 1) xs in
      length_acc 0 lst;;

    length [1;2;3;4;5];;
    length [];;
#+end_src

#+RESULTS:
: 0

*** 5

Reverse a list

#+begin_src ocaml

    let rec rev lst = match lst with
      | [] -> []
      | x :: xs -> (rev xs) @ (x::[]);;

    rev [1;2;5;4;3]
#+end_src

#+RESULTS:
| 3 | 4 | 5 | 2 | 1 |

*** 6
Find out whether a list is a palindrom

#+begin_src ocaml

   let rec is_palindrome lst =
     let revlst = rev lst in
     let rec list_equals l1 l2 = match l1 with
       | [] -> (match l2 with
                | [] -> true
                | y :: ys -> false)
       | x :: xs -> (match l2 with
                     | [] -> false
                     | y :: ys -> (match y with
                                   | y when y = x -> list_equals xs ys
                                   | _ -> false)) in
   list_equals lst revlst;;

   [is_palindrome [1;2;2;1];
    is_palindrome [1];
    is_palindrome [];
    is_palindrome [1;2;3;4;5;4;3;2;1];
    is_palindrome [1;2;3;4;3];
    is_palindrome [1;2;3]]

#+end_src

#+RESULTS:
| true | true | true | true | false | false |

*** 7

Flatten a nested list structure

#+begin_src ocaml :results verbatim
    (* type definition for nested list *)
    type 'a node =
      | One of 'a 
      | Many of 'a node list;;

    let rec flatten nl = match nl with
      | [] -> []
      | (One x) :: xs -> x :: flatten xs
      | (Many xs) :: xss -> (flatten xs) @ (flatten xss);;

    flatten [One "a"; Many [One "b"; Many [One "c" ;One "d"]; One "e"]]
#+end_src

#+RESULTS:
: - : string list = ["a"; "b"; "c"; "d"; "e"]

*** 8

Eliminate consecutive duplicates of list elements.

#+begin_src ocaml

    let rec compress l = match l with
      | [] -> []
      | x :: [] -> x :: []
      | x :: y :: xs when x = y -> compress (y :: xs)
      | x :: y :: xs when x <> y -> x :: compress (y :: xs);;

    compress [1;1;1;1;2;2;2;2;3;3;4;4;5;5;6;5;4]
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 |

*** 9

Pack consecutive duplicates of list elements into sublists

#+begin_src ocaml

  let pack l =
    let rec pack_help h l = match h with
      | [] -> (match l with
               | [] -> []
               | x :: xs -> pack_help [x] xs)
      | y :: ys -> (match l with
                    | [] -> [h]
                    | x :: xs -> match x with
                                      | x when x = y -> pack_help (x :: h) xs 
                                      | _ -> h :: (pack_help [x] xs)) in
    pack_help [] l;;

  pack [1;1;1;2;2;3;3;3;3;3;4;5;6;4]
#+end_src

*** 10

Run-length encoding of a list

#+begin_src ocaml

  let encode l =
    let rle x = (List.length x, List.hd x) in
    l |> pack |> List.map rle;;

  encode [1;1;1;1;2;3;4;4;4;4;4;4;4;4;3;3;2]
#+end_src

#+RESULTS:
| 4 | 1 |
| 1 | 2 |
| 1 | 3 |
| 8 | 4 |
| 2 | 3 |
| 1 | 2 |


** Advent of Code 2021
*** Day 1 - Sonar Sweep
**** Part 1:
Given a ~tally~ of the number of increases already seen, the
~previous~ integer from the file, and the ~in_channel~ ready to spit
out the next integer in the file:

If you're done reading the file, then ~tally~ is the
answer. Otherwise, check whether the ~next~ integer in the file is
bigger than the ~previous~ one, and recursively call ~count_increases~
with appropriately updated ~tally~ and ~previous~ parameters.

#+begin_src ocaml
    let count_increases filename =
      let input = open_in filename in
      let rec count_increases tally previous f =
        try (let next = f
                        |> input_line
                        |> int_of_string in
             match next with
             | a when a > previous -> count_increases (tally + 1) next f
             | _ -> count_increases tally next f
            ) with End_of_file -> tally in
      let first = input
                |> input_line
                |> int_of_string in
      count_increases 0 first input;;
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml :results verbatim
  count_increases "input1-1.txt"
#+end_src

#+RESULTS:
: - : int = 1215
**** Part 2:

Give a ~tally~ of how many increases you've seen so far, and also
~prev1~, ~prev2~ and ~prev3~ the three previous entries in the input,
then all that matters for updating the tally is whether the ~next~ input is bigger than ~prev1~.

#+begin_src ocaml
    let count_window_increases filename =
      let input = open_in filename in
      let rec window_increases tally prev1 prev2 prev3 f =
        try ( let next = f
                         |> input_line
                         |> int_of_string in
              match next - prev1 with
              | d when d > 0 -> window_increases (tally+1) prev2 prev3 next f
              | _ -> window_increases tally prev2 prev3 next f
            ) with End_of_file -> tally in
    let first = input
                |> input_line
                |> int_of_string in
    let second = input
                |> input_line
                |> int_of_string in
    let third = input
                |> input_line
                |> int_of_string in
    window_increases 0 first second third input;;
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml :results verbatim
  count_window_increases "input1-2.txt"
#+end_src

#+RESULTS:
: - : int = 1150
*** Day 2 - Dive!
**** Part 1

#+begin_src ocaml
  let dive filename =
    let input = open_in filename in
    let rec dive horizontal depth f =
      try (let nextline = input_line f in
           let [direction; value_str] = String.split_on_char ' ' nextline in
           let value = int_of_string value_str in
           match direction with
           | "forward" -> dive (horizontal + value) depth f
           | "up" -> dive horizontal (depth - value) f
           | "down" -> dive horizontal (depth + value) f)
      with End_of_file -> (horizontal * depth) in
  dive 0 0 input;;
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml
  dive "input2-1.txt"
#+end_src

#+RESULTS:
: 2073315

**** Part 2

#+begin_src ocaml
  let dive2 filename =
    let input = open_in filename in
    let rec dive h d a f =
      try (let nextline = input_line f in
           let [direction; x_str] = String.split_on_char ' ' nextline in
           let x = int_of_string x_str in
           match direction with
          | "up" -> dive h d (a - x) f
          | "down" -> dive h d (a + x) f
          | "forward" -> dive (h + x) (d + a*x) a f)
      with End_of_file -> (h*d) in
    dive 0 0 0 input;;
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml
  dive2 "input2-1.txt"
#+end_src

#+RESULTS:
: 1840311528

*** Day 3 - Binary Diagnostics
**** Part 1
#+begin_src ocaml

  let consumption filename =
    let len = filename
              |> open_in
              |> input_line
              |> String.length in
    let input = filename
                |> open_in in
    let rec zero_list l = match l with
      | 0 -> []
      | _ -> 0 :: zero_list (l-1) in
    let initial_tally = zero_list len in
    let rec update_tally tally bitline =
      match String.length bitline with
      | 0 -> []
      | b -> match (String.sub bitline 0 1) with
             | "1" -> (match tally with
                       | h::tl -> (h+1) :: (update_tally tl (String.sub bitline 1 (b-1))))
             | "0" -> (match tally with
                       | h::tl -> h :: (update_tally tl (String.sub bitline 1 (b-1)))) in
    let rec full_tally tl in_ch = try
        (let next_line = input_line in_ch in
         full_tally (update_tally tl next_line) in_ch)
      with End_of_file -> tl in
    let final_tally = full_tally initial_tally input in
    let rec number_of_entries count in_ch =
      try (let trash = (input_line in_ch) in number_of_entries (count+1) in_ch)
      with End_of_file -> count in 
    let entry_count = number_of_entries 0 (open_in filename) in
    let exp a p = match p with
      | 0 -> 1
      | _ -> a * exp a (p-1) in
    let rec gamma g c tally = match tally with
      | [] -> g
      | h :: tl -> match h with
                   | a when a > (entry_count/2) -> gamma (g + exp 2 (c-1)) (c-1) tl
                   | a when a < (entry_count/2) -> gamma g (c-1) tl in
    let gam = gamma 0 len final_tally in
    let eps = (exp 2 (len)) - gam - 1 in
    (gam, eps, gam*eps);;

  consumption "input3-1.txt"

#+end_src

#+RESULTS:
| 493 | 499 | 493 | 513 | 473 | 483 | 488 | 505 | 517 | 505 | 492 | 471 |

*** Day 6 - Lanternfish

Given a countdown ~c~ and a number of days ~d~, write a recursive
function for the number of lanternfish there will be after ~d~
days. Keep a cache of values to avoid exponential-time blowups.

#+begin_src ocaml
      let rec lf c d =
        let cache = Hashtbl.create 100 in
        let rec lf_mem x y =
          try
            Hashtbl.find cache [x;y]
          with
            Not_found ->
             match y with
             | 0 -> (Hashtbl.add cache [x;y] 1; 1)
             | _ -> match x with
                    | x when x > 0 -> let ans = lf_mem (x-1) (y-1) in
                                      (Hashtbl.add cache [x;y] ans; ans)
                    | _ -> (let ans = lf_mem 6 (y-1) + lf_mem 8 (y-1) in
                           (Hashtbl.add cache [x;y] ans; ans))
        in lf_mem c d;;
#+end_src

#+RESULTS:
: <fun>

#+begin_src ocaml
  let lanternfish filename days =
    let rec sum = function
      | [] -> 0
      | head::tail -> head + (sum tail) in
    filename
    |> open_in
    |> input_line
    |> String.split_on_char ','
    |> List.map int_of_string
    |> List.map (fun c -> lf c days)
    |> sum;;
#+end_src
 
#+RESULTS:
: <fun>

#+begin_src ocaml
  lanternfish "input6-1.txt" 80
#+end_src

#+RESULTS:
: 354564

**** Part 2

The memoization was probably not necessary for part 1, but would have
been for part 2.

#+begin_src ocaml
  lanternfish "input6-1.txt" 256
#+end_src

#+RESULTS:
: 1609058859115

*** Day 7 - The Treachery of Whales
**** Part 1

If ~h~ is chosen horizontal position to align to, then the total fuel
consumed is the sum of ~abs(x-h)~ as ~x~ ranges over all the initial
positions specified in the input.

If you increase ~h~ by ~a~, this sum will increase by ~a~ times the number of positions
~x~ that are less than ~h~, and it will decrease by ~a~ times the
number of positions ~x~ that are greater than ~h~.

In other words, the values of ~h~ that minimized the total fuel
function is one with the same number of position values ~x~ greater
than it and less than it. This is the median of the input list if it
has odd length, and is any number between the two middle values if
the input list has even length.

So all we have to do is take the input list, find its median ~h~, and
sum ~|x-h|~ for all ~x~ in the input list

Finding the median of an unsorted list can be done in linear time, so
sorting is not optimal here.

#+begin_src ocaml

  let minimize_fuel filename =
    let input_list = filename
                     |> open_in
                     |> input_line
                     |> String.split_on_char ','
                     |> List.map int_of_string
                     |> List.sort (fun a b -> a - b) in
    let median = List.nth input_list ((List.length input_list)/2) in
    let rec fuelsum list h partial =
      match list with
      | [] -> partial
      | x::t -> fuelsum t h (partial + abs(x - h)) in
    fuelsum input_list median 0;;

  minimize_fuel "input7-1.txt"
#+end_src

#+RESULTS:
: 323647

*** Day 10 - Syntax Scoring
**** Part 1

To check whether a string is balanced or not, use a stack. Push
opening characters onto the stack. When closing characters are
encountered, pop the stack if it matches. Otherwise, that's the first
incorrect character. If you get to the end of the string and the stack
is empty, it's a balanced expression. But if you get to the end of the
string and the stack still has characters, it's incomplete
*** Day 14 - Polymerization

#+begin_src ocaml

  let polymerization filename =
    let input = filename
                |> open_in in
    let rec file_to_list_of_strings lst inpt =
      (try let next_line = input_line inpt in
           file_to_list_of_strings (lst @ [next_line]) inpt
       with
         End_of_file -> lst) in
    let input_list = file_to_list_of_strings [] input in
    let initial_string = List.hd input_list in
    let insertions = Hashtbl.create 256 in
    let parse_rule r h =
      Hashtbl.add h (String.sub r 0 1) (String.sub r 6 6) in
    let

  polymerization "input14-1.txt"
#+end_src

#+RESULTS:
: PBVHVOCOCFFNBCNCCBHK

*** Day 18 - Snailfish numbers

**** Part 1

Use a custom type.
